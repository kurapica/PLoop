# 类和接口(class & 接口)

类(class)系统是**PLoop**的核心系统，之前的原型(prototype)系统也只是为了便于构建服务于类的原型，而枚举(enum)和结构体(struct)都是用于扩展Lua的数据类型和校验，这样类系统只需要关于在类的构建和使用上。

在编程开发中，我们称运行中使用的带有数据和操作的实体为对象，例如代表持有特定人信息（比如名字，生日等）的table(`{ name = "Ann", birth = '2010-01-01' }`，我们可以认为它是一个对象实体。

通常Lua开发代码使用函数来执行操作，例如`setName(ann, "Ann")`，当这类函数数量很庞大时，管理就成为了问题，为了避免重名，我们就需要为它添加不同的前缀`Person_SetName`，而为了避免函数误用`Person_SetName(school，"USTC")`，我们又需要针对每个函数添加校验，等需要重构时，整理这些的代价都很大。

所以，Lua提供了面向对象的访问方式: `ann:SetName("Ann")`，它的完整写法是`ann.SetName(ann, "Ann")`。`ann.SetName`是table实体访问自身字段的方式，只要我们确保这个函数的第一个参数是对象实体，我们就可以用`:`来调用保存在自身字段中的函数，并将自己作为第一个参数传入，既可以省略代码，又能强调，这是一个对象自身方法的调用。

每种table实体都有同样的一组方法，因为我们只能通过table自身访问这些方法，那么方法本身也就不需要校验调用者的类型。而更进一步，不同类型的table实体可以具有同名的方法，比如代表学校的`school`和代表人的`person`都可以具有`SetName`同名方法，那么，在一些只关心对象实体具有`SetName`方法的处理中，我们只需要使用`obj:SetName(xx)`而不关心它们的实际类型。

实际，我们并不能为每个table实体保存一组方法，即浪费了复制方法的时间，也造成了额外的占用（虽然的确有面向对象库这么实现）。通常，我们会给同一类table设置同样的元表，这些元表提供`__index`元表配置，来提供这些方法：

```lua
local Person = {}
Person.__index = Person

function Person:New(tbl)
	return setmetatable(tbl or {}, self)
end

-- 定义实体方法
function Person:SetName(name)
	self.name = name
end

function Person:GetName(name)
	return self.name
end

ann = Person:New()

ann:SetName("Ann")
```

这里的Person我们称为对于类似`ann`这样的同一类对象的抽象，也就是类(class)，而对象是类的实现。对于Lua而言，类为对象实体提供了统一的元表，来提供默认的字段（对应方法）以便操作对象。类的对象具有同样的元表，这也是它们和其他对象的区分。

通常，Lua的类系统相当简单，类似于上例就可以构造成一整套面向对象库，但这样的类系统过于简单，它很难满足一些企业级开发的需求，例如：多继承，类的重定义，多版本类管理（对应多线程环境）等等。我们会看到**PLoop**为类系统提供的丰富资源。

类和接口本身只提供了对象的构造，初始化和方法，更多的资源类似对象属性和对象事件是由其他原型注册到类和接口系统来提供额外功能的，实现细节并不妨碍我们直接使用它们。在进阶说明中，我们再对它们的实现进行说明。


## 目录

* [对象方法](#对象方法)
	* 对象方法的参数验证(#对象方法的参数验证)
	* 对象方法的重载(#对象方法的重载)
* [对象构造和重载系统](#对象构造和重载系统)
	* [构造体`__ctor`](#构造体__ctor)
		* [重载构造体方法](#重载构造体方法)
	* [初始化字段`__field`](#初始化字段__field)
	* [生成器`__new`](#生成器__new)
	* [复用检查`__exist`](#复用检查__exist)
	* [对象的构造](#对象的构造)
	* [the `__new` with init-table](#the-__new-with-init-table)
	* [在构造体中抛出错误](#在构造体中抛出错误)
* [对象的销毁](#对象的销毁)
* [元表方法](#元表方法)
* [静态方法](#static-method)
* [继承](#继承)
* [多版本类](#多版本类)
* [扩展类的方法](#扩展类的方法)
* [接口(interface)](#接口interface)
	* [接口的匿名类](#接口的匿名类)
	* [限定接口的扩展类](#限定接口的扩展类)
* [事件(event)](#事件event)
	* [事件处理函数的特性](#事件处理函数的特性)使用
	* [监听事件处理函数的变更](#监听事件处理函数的变更)
	* [静态事件](#静态事件)
	* [超类事件](#超类事件)
* [属性(Property)](#属性property)
	* [属性访问(get/set)](#属性访问getset)
	* [指定方法名访问属性(getmethod/setmethod)](#指定方法名访问属性getmethodsetmethod)
	* [错误抛出(throw)](#错误抛出throw)
	* [内部字段和默认值(field & default)](#内部字段和默认值field--default)
	* [默认值构造函数(default factory)](#默认值构造函数default-factory)
	* [属性事件(event)](#属性事件event)
	* [属性处理方法(handler)](#属性处理方法handler)
	* [静态属性(static)](#静态属性static)
	* [自动方法绑定(Auto-binding)](#自动方法绑定auto-binding)
	* [超类属性调用(super)](#超类属性调用super)
	* [索引器属性(indexer)](#索引器属性indexer)
	* [属性的访问修饰(Get/Set Modifier)](#属性的访问修饰getset-modifier)
* [继承和优先级](#继承和优先级)
* [使用其他定义形式](#使用其他定义形式)
	* [使用字符串作为定义体](#使用字符串作为定义体)
	* [使用表作为定义体](#使用表作为定义体)
* [泛型类和泛型接口](#泛型类和泛型接口)
* [System.Interface](#systeminterface)
	* [GetExtends](#interfacegetextends)
	* [GetFeature](#getfeature)
	* [GetFeatures](#getfeatures)
	* [GetMethod](#getmethod)
	* [GetMethods](#getmethods)
	* [GetMetaMethod](#getmetamethod)
	* [GetMetaMethods](#getmetamethods)
	* [GetRequireClass](#getrequireclass)
	* [GetSubTypes](#getsubtypes)
	* [GetSuperMethod](#getsupermethod)
	* [GetSuperMetaMethod](#getsupermetamethod)
	* [GetSuperFeature](#getsuperfeature)
	* [GetSuperRefer](#getsuperrefer)
	* [GetTemplate](#gettemplate)
	* [GetTemplateParameters](#gettemplateparameters)
	* [HasAnonymousClass](#hasanonymousclass)
	* [IsAbstract](#isabstract)
	* [IsFinal](#isfinal)
	* [IsImmutable](#isimmutable)
	* [IsSealed](#issealed)
	* [IsStaticMethod](#isstaticmethod)
	* [IsSubType](#issubtype)
	* [ValidateValue](#validatevalue)
	* [Validate](#validate)
* [System.Class](#systemclass)
	* [AttachObjectSource](#attachobjectsource)
	* [GetExtends](#getextends)
	* [GetFeature](#getfeature)
	* [GetFeatures](#getfeatures)
	* [GetMethod](#getmethod)
	* [GetMethods](#getmethods)
	* [GetMetaMethod](#getmetamethod)
	* [GetMetaMethods](#getmetamethods)
	* [GetObjectClass](#getobjectclass)
	* [GetObjectSource](#getobjectsource)
	* [GetSubTypes](#getsubtypes)
	* [GetSuperClass](#getsuperclass)
	* [GetSuperMethod](#getsupermethod)
	* [GetSuperMetaMethod](#getsupermetamethod)
	* [GetSuperFeature](#getsuperfeature)
	* [GetSuperObjectStyle](#getsuperobjectstyle)
	* [GetSuperRefer](#getsuperrefer)
	* [GetTemplate](#gettemplate)
	* [GetTemplateParameters](#gettemplateparameters)
	* [IsAbstract](#isabstract)
	* [IsFinal](#isfinal)
	* [IsImmutable](#isimmutable)
	* [IsObjectAttributeEnabled](#isobjectattributeenabled)
	* [IsObjectFunctionAttributeEnabled](#isobjectfunctionattributeenabled)
	* [IsObjectSourceDebug](#isobjectsourcedebug)
	* [IsObjectType](#isobjecttype)
	* [IsMethodAutoCache](#ismethodautocache)
	* [IsNilValueBlocked](#isnilvalueblocked)
	* [IsRawSetBlocked](#israwsetblocked)
	* [IsSealed](#issealed)
	* [IsSingleVersion](#issingleversion)
	* [IsStaticMethod](#isstaticmethod)
	* [IsSubType](#issubtype)
	* [ValidateValue](#validatevalue)
	* [Validate](#validate)
* [System.Event](#systemevent)
	* [IsStatic](#isstatic)
	* [Invoke](#invoke)
	* [Validate](#validate)
* [System.Property](#systemproperty)
	* [GetField](#getfield)
	* [IsGetClone](#isgetclone)
	* [IsGetDeepClone](#isgetdeepclone)
	* [IsIndexer](#isindexer)
	* [IsReadable](#isreadable)
	* [IsSetClone](#issetclone)
	* [IsSetDeepClone](#issetdeepclone)
	* [IsRetainObject](#isretainobject)
	* [IsStatic](#isstatic)
	* [IsThrowable](#isthrowable)
	* [IsWeak](#isweak)
	* [IsWritable](#iswritable)
	* [GetDefault](#getdefault)
	* [GetType](#gettype)
	* [Validate](#validate)
* [System.Delegate](#systemdelegate)
	* [CopyTo](#CopyTo)
	* [Invoke](#Invoke)
	* [IsEmpty](#IsEmpty)
	* [SetInitFunction](#SetInitFunction)
	* [SetFinalFunction](#SetFinalFunction)

## 对象方法

结构体定义中，我们可以定义方法，这些方法会被保存到被验证过后的table实体中，同样，在类的定义体中，我们也可以随意定义一些函数（非**PLoop**使用的名字，通常这些字段要麽是关键字，要麽是`__`开始），这些函数将作为类的对象的方法被使用：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		function SetName(self, name)
			self.name = name
		end

		function GetName(self, name)
			return self.name
		end
	end)

	Ann = Person()
	Ann:SetName("Ann")
	print("Hello " .. Ann:GetName())       -- Hello Ann

	Ben = Person{ name = "Ben" }
	print("Hello " .. Person.GetName(Ben)) -- Hello Ben
end)
```

注意，**PLoop**生成的对象，实际只是具有特定元表的table，所以，上述`self.name`的读写是直接对table内的`name`字段进行读写。上述类定义生成对象元表就是

```lua
{
	__metatable = Person,
	__index = {
		SetName = function(self, name) self.name = name end,
		GetName = function(self) return self.name end,
	}
}
```

所以，它只是为对象提供了两个默认的方法。

我们定义的**Person**类可以被用于创建对象，和一般面向对象的例子不同，我们不会使用`Person:New()`的形式，一个原因，是通常我们尽可能将这类名字保留给作者使用，另一个原因是，对象的构造实际非常复杂，接下来会看到对象构造的几种情况。

对于简单的没有定义自己的构造体的类，我们可以直接传入table作为对象的初始化定义，这个表的所有键值对都会依次保存进入创建出来的对象中（并不会使用传入的table作为对象，而是复制它里面的值，这些值也可以是函数，用于替代默认的对象方法等）。

除了在对象中调用这些对象方法外，我们也可以直接使用`类.方法名`的形式来访问这些函数，当然，此时需要自行传入对象，因为通常不存在对对象的验证，所以这种方法除非能完全确认对象满足调用条件，请尽少使用。


### 对象方法的参数验证

之前在环境中，我们可以为函数使用`__Arguments__`特性来校验参数，同样，我们也可以为对象方法使用这个特性，不同的是，参数验证时，第一个参数默认为对象，也就是方法的调用者，所以，是不参与验证的:

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Arguments__{ String }
		function SetName(self, name)
		end
	end)

	o = Person()

	-- Error: xxx.lua:11: Usage: Person:SetName(System.String) - the 1st argument must be string, got number
	o:SetName(1)
end)
```

所以，直接使用`Person.SetName`时，需要注意，作为第一个参数的对象，是不会被验证的。不过，通常情况下，我们很少需要直接使用类调用对象方法。


### 对象方法的重载

不同于在环境中使用`__Arguments__`特性，在类定义中使用这个特性时，还有一个额外的功能，就是重载，意思就是我们可以定义同一个名字的不同函数，用于对不同的参数列表进行处理:

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Arguments__{ String }
		function SetInfo(self, name)
			self.name = name
		end

		__Arguments__{ Number }
		function SetInfo(self, age)
			self.age = age
		end

		__Arguments__{ String, Number }
		function SetInfo(self, name, age)
			self:SetInfo(name)
			self:SetInfo(age)
		end

		__Arguments__{ Number, String }
		function SetInfo(self, age, name)
			self:SetInfo(age)
			self:SetInfo(name)
		end
	end)

	o = Person()

	o:SetInfo("ann", 12)
	print(o.name, o.age) -- ann  12

	o:SetInfo(15, "ben")
	print(o.name, o.age) -- ben  15
end)
```

Lua通常函数处理时，如果需要对应不同的参数调用方式，需要书写很多的逻辑判定，再继续处理，而配合`__Arguments__`的参数指定，系统可以很容易的根据调用参数，选择出对应的函数。在各个组成重载方法的函数中，我们依然可以使用对象调用这个方法，来实现更多的分流处理，但请注意，不要形成递归调用。

**下面这段话不理解也无需在意，不会影响你使用重载系统，能理解原理，可以更清晰理解PLoop的细节，毕竟这是基于纯Lua，没有参杂额外的无法理解的东西**

	这个的实现机制在于，给类定义方法时，实际并不会将方法保存在定义环境中，因为通常很少需要再定义环境中直接调用这些方法（一般都是走`self:Callxxx()`，而不是直接`Callxxx(self)`），所以，环境可以再次处理同名函数的申明，而`__Arguments__`特性可以修改函数的定义，将它和以前定义的同名函数捆绑在一起，作为对象的方法使用。

	特别注意，重载这个机制，并非由类系统实现，实际类系统本身没有重载这个概念，只有对象方法，以及重新定义对象方法时，覆盖原本的定义这个机制。重载完全由`__Arguments__`特性自行实现。这样的设计是为了避免功能都堆积在类系统中，


## 对象构造和重载系统

在之前的例子中，我们使用了`Person()`和`Person{ Name = "Ben" }`来生成对象实体，这是**PLoop**类的默认构造行为: 无参数构造和初始化表构造两个机制。

实际场合，构造对象相对要复杂很多，我们需要考虑对象的创建，复用，多继承情况下的初始化等情况。


### 构造体`__ctor`

通常，对象table的构建由系统完成，系统在构建新table后并为它设置了元表后，和构造用的参数一并传递给类的构造体函数，在那里根据参数对新对象进行初始化操作，这个过程称为对象的构造：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		function __ctor(self, name, age)
			self.name = name
			self.age = age
		end
	end)

	Ann = Person("Ann", 12)

	-- Ann  12
	print(Ann.name, Ann.age)

	Ben = Person{ name = "Ben" }

	-- table: 00DA7F50
	print(Ben.name)
end)
```

我们使用`__ctor`为类申明构造体方法，如果不是匿名类，也可以用类名来申明构造体方法。构造体方法会接受新创建的对象作为第一个参数， 以及其他的传入的参数。

同时，在给定了构造体后，系统不会尝试将传入的唯一table作为初始化表，而是直接转给构造体方法处理，这点确保作者对类有绝对的控制权，默认处理只是在作者不处理时，提供便利。

在上面的例子中，`name`被错误的赋给了table值，为了验证，我们也可以使用`__Arguments__`特性：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Arguments__{ String, Number }
		function __ctor(self, name, age)
			self.name = name
			self.age = age
		end
	end)

	Ann = Person("Ann", 12)

	-- Ann  12
	print(Ann.name, Ann.age)

	-- Error: Usage: Person(System.String, System.Number) - the 1st argument must be string, got table
	Ben = Person{ name = "Ben" }

	-- Error: Usage: Person(System.String, System.Number) - the 2nd argument can't be nil
	Ben = Person("Ben")
end)
```

#### 重载构造体方法

类似对象方法，除了用`__Arguments__`特性来进行参数验证外，我们还可以用它实现构造体方法的重载：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Arguments__{ String, Number }
		function __ctor(self, name, age)
			self.name = name
			self.age = age
		end

		__Arguments__{ String }
		function __ctor(self, name)
			this(self, name, 1)
		end

		__Arguments__{ Number }
		function __ctor(self, age)
			this(self, "anonymous", age)
		end
	end)

	-- anonymous
	print(Person(100).name)

	-- 1
	print(Person("Ann").age)

	Ben = Person("Ben", 30)

	-- Ben  30
	print(Ben.name, Ben.age)
end)
```

注意，和对象方法不同，构造体方法并不能由对象自身调用，所以，我们无法使用`self:__ctor(xxx)`的形式来调用不同的处理函数，重载系统为构造体方法提供了`this`关键字，将对象和参数传入即可，重载系统会根据参数选择合适的处理函数，继续进行处理。

`this`同样可以用于之后的`__new`和`__exist`方法，虽然它们并不传递对象。但`this`不可用于对象方法等情况，仅对象构造时可以使用。

上面的情况下，也可以利用`__Arguments__`提供默认值来处理：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Arguments__{ String/"anonymous", Number/1 }
		function __ctor(self, name, age)
			self.name = name
			self.age = age
		end
	end)

	-- anonymous
	print(Person(nil, 100).name)

	-- 1
	print(Person("Ann").age)

	Ben = Person("Ben", 30)

	-- Ben  30
	print(Ben.name, Ben.age)

	nobody = Person()

	-- anonymous  1
	print(nobody.name, nobody.age)
end)
```


### 初始化字段`__field`

如果我们使用比较严格的开发模式，禁止对类对象字段的直接读写（只能访问定义的方法等）:

```lua
PLOOP_PLATFORM_SETTINGS = { OBJECT_NO_RAWSEST = true, OBJECT_NO_NIL_ACCESS = true }

require "PLoop"(function(_ENV)
	-- 不通过平台设定的话，也可以使用下面两个特性
	-- __NoNilValue__() __NoRawSet__()
	class "Person" { }

	o = Person()

	-- Error: xxx.lua:9: The object can't accept field that named "name"
	o.name = "Ann"
end)
```

这个用法的一个问题就是需要不断的使用`rawset/rawget`来读写数据，这并不方便，也容易遗留问题，但如果我们在对象构造时，就提供一些字段和默认值给这个对象，那么读写这些字段都不需要通过元表进行，而且，也避免了拼写错误写入到错误字段中。

为了简化操作，**PLoop**提供了默认字段的申明方式，可以使用`__field`指定，或者`field`关键字(名字虽然不够特殊，但PLoop的关键字也不是真正的关键字，是不会阻止你使用它作为变量的)：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		-- 我们可以直接用table设定默认字段，注意
		-- 重复定义这个table会清掉之前的设定，包括
		-- 从超类继承的默认字段
		__field = { name = "anonymous" }

		-- 我们也可以使用field关键字申明，这种定义
		-- 不会清掉以前的设定，这种适合在继承系统中使用
		-- 按照继承关系，一路继承各种默认字段定义
		field { age = 1 }
	end)

	-- anonymous
	print(Person{ age = 10 }.name)

	-- 1
	print(Person{ name = "Ann" }.age)

	Ben = Person{ name = "Ben", age = 30 }

	-- Ben  30
	print(Ben.name, Ben.age)

	nobody = Person()

	-- anonymous  1
	print(nobody.name, nobody.age)
end)
```


### 生成器`__new`

通常对象实体由系统自动构建，这样在`__ctor`中对对象初始化时，已经可以使用对象的各类资源，例如对象方法，以及之后的属性等。

但部分场合下，由系统构建对象会造成很大的性能浪费，例如，我们定义一个将接受的参数保存为数组的类型：

```lua
require "PLoop" (function(_ENV)
	class "List" (function(_ENV)
		function __ctor(self, ...)
			for i = 1, select("#", ...) do
				self[i] = select(i, ...)
			end
		end
	end)

	lst = List(1, 2, 3)
end)
```

将所有参数保存进对象，相对`{ 1, 2, 3, 4 ... }`直接构建的方式而言，会极大的增加时间消耗，所以，在部分场合，我们需要能直接创建出table，然后交给系统赋予元表，这样完成对象的生成，这个是通过指定生成器方法来完成：

```lua
require "PLoop" (function(_ENV)
	class "List" (function(_ENV)
		function __new(cls, ...)
			return { ... }, true
		end

		function __ctor(self, ...)
			print(select("#", ...)) -- 0
		end
	end)

	lst = List(1, 2, 3)
end)
```

因为对象需要由`__new`构建，它的第一个参数是类本身（也可能是继承这个类的字类），之后是构建对象用的其他参数，在`List`的生成器中，我们直接使用 `{...}`来构建对象，这避免了之后一个个赋值的处理。而它的第二个返回值为true时，系统将清掉传入的参数，在`__ctor`中，我们获取参数数量，拿到的是0。

注意，`__new`并非一定需要返回值，如果不满足条件，也可以不返回table，这样系统会沿用默认的处理，自行构建对象，再将对象和参数传给`__ctor`构造体方法。

我们也可以使用`__Arguments__`特性在生成器方法上，注意，第一个参数作为类型不会被验证。因为它本来就是由系统传入的，没有使用风险：

```lua
require "PLoop" (function(_ENV)
	class "List" (function(_ENV)
		__Arguments__{ Number * 2 }
		function __new(cls, ...)
			return { ... }, true
		end
	end)

	-- Error: Usage: List(... [*2] as System.Number) - the ... must contains at least 2 arguments
	lst = List(1)

	-- Error: Usage: List(... [*2] as System.Number) - the 4th argument must be number, got string
	lst = List(1, 2, 3, "hi")

	-- 5
	print(#List(1, 2, 3, 4, 5))
end)
```

同样，我们可以对`__new`使用重载技术，并且同作为构造对象用的处理，可以使用`this`关键字。


### 复用检查`__exist`

为了避免频繁构建对象，并且对象可以被复用时，我们可以使用`__exist`指定复用检查方法：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		_Persons = {}

		function __exist(cls, name)
			return _Persons[name]
		end

		function __ctor(self, name)
			_Persons[name] = self

			self.name = name
		end
	end)

	Ann = Person("Ann")

	-- true
	print(Ann == Person("Ann"))
end)
```

类似`__new`，它会接受类和所有参数，如果返回值是对应类的对象，那么就会被直接使用，后续的`__new`和`__ctor`都不会被调用（不存在新对象构造）。


### 对象的构造

对象构造涉及到`__exist`复用检查，`__new`生成器，`__field`默认字段和`__ctor`构造体方法这几大块，那么它们的实际调用流程如下:

```lua
-- 检查是否可以复用，可以复用就返回对象
local object = __exist(cls, ...)
if object then return object end

-- 通过生成器创建对象，或者直接创建一个table作为对象
object = __new(cls, ...) or {}

-- 复制默认字段，此时对象还是普通table，不会触发类的各种设定
copy(object, __field)

-- 设置元表，封装table成为类对象
setmetatable(object, objMeta)

-- 调用构造体方法
__ctor(object, ...)

-- 结束对象构造，返回对象
return object
```


### the `__new` with init-table

通常申明了构造体后，我们无法使用初始化表的机制进行处理，通常应该由作者自行处理，但如果只申明`__new`生成器，并且第二个参数不返回true，我们依然可以使用初始化表机制：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		local index = 0
		function __new(_, ...) index = index + 1 return { id = index } end
	end)

	o = Person{ name = "Ann" }

	print(o.id, o.name)  -- 1  Ann
end)
```


### 在构造体中抛出错误

尽管我们可以通过`__Arguments__`特性来验证参数，但无法保证构造体中不会抛出错误，通常错误有两种情况:

* 代码编写错误，这种抛出后，Lua提供的错误消息可以帮我们直接定位，所以通常无需处理。

* 判定后使用`error`抛出错误，这种一般我们期望，抛出错误定位在调用者位置。

后者定位实际很难由作者处理，对象构造本身由系统进行处理，所以，堆栈级别很难确认，加上之后介绍的继承系统，子类调用超类的构造体导致，堆栈级别会有更多的变化，所以，作者是无法在定义构造体方法时，确认堆栈级别来定位调用者位置的。

为了解决这个问题，**PLoop**引入了[异常处理](012.exception.md)，在构造体中（含生成器和复用确认），我们可以使用`throw`关键字来抛出错误信息，之后系统会将错误定位在调用者位置：

```lua
require "PLoop" (function(_ENV)
	class "A" (function(_ENV)
		function __ctor(self)
			throw("Something error")
		end
	end)

	-- Error: xxx.lua:9: Something error
	o = A()
end)
```

更详细的说明，参考[异常处理](012.exception.md)。


## 对象的销毁

Lua会自行回收不再使用的table，通常我们无需考虑对象的销毁，而是不再使用它，清掉一些指向它的引用即可，之后Lua会完成销毁操作。

但部分场合，我们在对象构造时，会对它进行注册，那么为了通知类反注册这些对象，我们主动的调用销毁方法。

销毁方法通常使用`__dtor`来定义，也可以使用`Dispose`来定义，注意，`Dispose`是**PLoop**唯一占用的普通(不以`__`开始)方法名，它仅用于定义类对象的销毁（也称为析构）方法（因为`self:__dtor()`毕竟不能算正常的调用方式）。

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		_Persons = {}

		function __dtor(self)
			_Persons[self.name] = nil
		end

		function __exist(self, name)
			return _Persons[name]
		end

		function __ctor(self, name)
			self.name = name
			_Persons[name] = self
		end
	end)

	Ann = Person("Ann")

	-- true
	print(Ann == Person("Ann"))

	Ann:Dispose()

	-- false
	print(Ann == Person("Ann"))
end)
```

在类定义了析构方法后，我们就可以调用对象的`Dispose`方法来解除对象的相关引用，便于之后被Lua回收。

通常，调用`Dispose`处理后，对象保存的内容会被清空，以便解除关系，并且它的`Disposed`字段会被设置为true，这也可以作为一个判定。

在某些特定场合，`Dispose`仅是部分代码申明这个对象不再被使用，但出于复用性的考虑，我们依然可以在构建对象时，复用这部分"销毁掉"的对象。为此我们需要告知系统，这些对象是可以被回收使用的，不需要清空它，也不用标记为`Disposed`。

这里可以使用`System.__Recyclable__`特性来描述类：

```lua
require "PLoop" (function(_ENV)
	__Recyclable__()
	class "Person" (function(_ENV)
		_Reusable = {}

		function __dtor(self)
			_Reusable[self] = true
		end

		function __exist(cls)
			local obj = next(_Reusable)
			if obj then
				_Reusable[obj] = nil
			end
			return obj
		end
	end)

	o = Person()

	o:Dispose()

	print(o == Person())
end)
```


## 元表方法

**PLoop**的类系统是依赖于元表的`__index`和`__newindex`两个元表方法，同时，也支持所有Lua提供的其他元表方法定义：

```lua
require "PLoop" (function(_ENV)
	class "Delegate" (function(_ENV)
		__Arguments__{ Function }
		function __add(self, func)
			for i = 1, #self do
				if self[i] == func then return end
			end
			self[#self + 1] = func
			return self
		end

		__Arguments__{ Function }
		function __sub(self, func)
			for i = #self, 1 do
				if self[i] == func then
					table.remove(self, i)
					break
				end
			end
			return self
		end

		function __call(self, ...)
			for i = 1, #self do
				self[1](...)
			end
		end
	end)

	del = Delegate()

	del = del + print

	-- 1  2  3
	del(1, 2, 3)

	del = del - print

	-- nothing happen
	del(1, 2, 3)
end)
```

不仅可以类似`__ctor`一样定义它们，还可以使用类似`__Arguments__`这样的特性在它们上面。

下面的列表是完整的元表方法，根据Lua版本不同，可能会有增减：

方法名          |描述
:--------------|:--------------
`__add`        |a + b  -- a是对象，由它的元表方法进行处理，下同
`__sub`        |a - b
`__mul`        |a * b
`__div`        |a / b
`__mod`        |a % b
`__pow`        |a ^ b
`__unm`        |- a
`__idiv`       |a // b
`__band`       |a & b
`__bor`        |a | b
`__bxor`       |a~b
`__bnot`       |~a
`__shl`        |a<<b
`__shr`        |a>>b
`__concat`     |a..b
`__len`        |#a
`__eq`         |a == b
`__lt`         |a < b
`__le`         |a <= b
`__index`      |return a[k]
`__newindex`   |a[k] = v
`__call`       |a(...)
`__gc`         |the garbage-collection
`__tostring`   |tostring(a)
`__ipairs`     |ipairs(a)
`__pairs`      |pairs(a)
`__exist`      |复用检查
`__field`      |初始化字段表
`__new`        |生成器
`__ctor`       |构造体方法
`__dtor`       |析构方法

通常你需要检查对应的Lua版本来确认这些元表方法是否能使用。


## 静态方法

我们也可以定义仅被类使用的方法， 这些就是静态方法，它们的第一个参数无需是对象。

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		local count = 0

		__Static__()
		function GetCount()
			return count
		end

		function __ctor(self, name)
			count = count + 1
			self.name = name
		end
	end)

	Ann = Person("Ann")
	Ben = Person("Ben")

	-- nil
	print(Ann.GetCount)

	-- 2
	print(Person.GetCount())
end)
```

我们也可以为它指定`__Arguments__`特性，不过，因为没有对象作为第一个无需验证的参数，静态方法的校验是从第一个参数开始：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		local count = 0

		__Static__()
		__Arguments__{ String/"anonymous" }
		function New(name)
			return Person{ name = name }
		end
	end)

	Ann = Person.New("Ann")

	-- Ann
	print(Ann.name)
end)
```


## 继承

每个类都可以，且仅可以有一个超类，类会从超类中继承所有的对象方法，和元表方法（包含生成器，构造体等），也会继承所有的对象资源（后面介绍的属性，事件）。

```lua
require "PLoop" (function(_ENV)
	print(_ENV)  -- table: 01168D00

	class "A" (function(_ENV)
		function Test() end
	end)

	class "B" (function(_ENV)
		inherit "A" -- 或者  inherit(A)

		print(Environment.GetParent(_ENV))  -- table: 01168D00
	end)

	B():Test()
end)
```

上面使用`inherit`关键字来表明当前被定义的类`B`继承自`A`，注意`"A"`的用法，实际这是表示从当前环境中读取即`_ENV["A"]`，而`B`的定义环境的基础环境就是`B`被定义的位置，在这个环境中，A已经被定义，所以，通过`_ENV["A"]`的访问，我们可以拿到这个`A`类，以这种角度来说`inherit "A"`等同于 `inherit(_ENV["A"])`，而`inherit(A)`等同于`inherit(_ENV.A)`，两者是一致的。

通常我们说被继承的类为超类，而继承了对方的类被称为子类。

子类可以重新定义这些对象方法，元表方法等，这样在使用同一类对象时（源于同一个超类），我们只需要调用同名的方法，由对象根据自己的类型完成不同的操作。

更进一步，子类并非需要完成全部处理，覆盖超类方法后，也无需自己实现超类已经完成的功能，它们可以使用`super`关键字来调用超类的资源：

```lua
require "PLoop" (function(_ENV)
	class "A" (function(_ENV)
		function Test(self)
			print("调用A的方法")
		end

		function __ctor(self)
			print("调用A的构造体")
		end

		function __dtor(self)
			print("调用A的析构方法")
		end

		-- Meta-method
		function __call(self)
			print("使用A的__call元表方法")
		end
	end)

	class "B" (function(_ENV)
		inherit "A"

		function Test(self)
			print("调用B的方法")
			super[self]:Test()
			super.Test(self)
			print("结束B的方法调用")
		end

		function __ctor(self)
			print("调用B的构造体")
			super(self)
			super.__ctor(self)
			print("结束调用B的构造体")
		end

		function __dtor(self)
			print("调用B的析构方法")
		end

		function __call(self)
			print("调用B的__call元表方法")
			super[self]:__call()
			super.__call(self)
			print("结束调用B的__call元表方法")
		end
	end)

	-- 调用B的构造体
	-- 调用A的构造体
	-- 调用A的构造体
	-- 结束调用B的构造体
	o = B()

	-- 调用B的方法
	-- 调用A的方法
	-- 调用A的方法
	-- 结束B的方法调用
	o:Test()

	-- 调用B的__call元表方法
	-- 使用A的__call元表方法
	-- 使用A的__call元表方法
	-- 结束调用B的__call元表方法
	o()

	-- 调用B的析构方法
	-- 调用A的析构方法
	o:Dispose()
end)
```

上面的一些细节解释：

* 析构方法不存在调用超类析构，系统会按照继承属性，进行调用，子类的析构执行后，再执行超类的析构处理。

* 我们可以使用`super.xxx`的形式访问所有超类被该子类覆盖的对象方法，以及元表方法（含构造体方法等），需要将对象作为第一个参数传入。

* 除此之外，系统还提供了一种超类对象访问的形式:`super[self]:Test()`，这种常用于多线程平台使用时，为了对应多次修改类（修改文件后，重载造成类被重新定义等）造成的多个版本（已生成对象不使用新的定义，避免冲突），`super[self]`这种形式可以唯一确认类的一个版本，然后使用该版本下的处理。通常Lua用于单线程平台，如果在`PLOOP_PLATFORM_SETTINGS`设定中关闭了多版本类，那么使用`super.xxx(self)`的形式即可，或者可以确定不会有多版本的场合，也可以只使用`super.xxx(self)`的形式，除此之外，推荐使用超类对象访问的代码形式。可以有效防止多版本类存在时，调用版本不正确的问题。

* 对于`__ctor`构造体，我们可以省略为`super(self)`。相对而言，其他超类调用很少见。注意，子类提供构造体方法后，如何调用超类的构造方法完全由子类决定，包括调用时机和参数。


## 多版本类

类似枚举类型和结构体，如果我们不使用`__Sealed__`锁定类，我们依然可以不断的重定义它，不过和数据类型不同，重定义类不会清掉一些的设定，而只是定义新的或者覆盖已有的资源。

```lua
require "PLoop" (function(_ENV)
	class "A" (function(_ENV)
		function test(self)
			print("hi")
		end
	end)

	o = A()

	class "A" (function(_ENV)
		function test(self)
			print("hello")
		end
	end)

	o:test()   -- hi
	A():test() -- hello
end)
```

可见，已经生成的对象，并没有获得新定义的方法，我们并非是将旧定义的`test`方法保存在对象中，而是因为`A`类在定义后，是形成了一个新的版本，注意，一个类和它的定义实际是分开的，一个类可以关联多个版本的定义，以类为入口只能访问到最新的版本。但对象可以保留使用旧版本的定义，这是为了避免，新版本的定义对对象的字段等做了很多调整，那么新方法中调用对象的处理，很可能在旧对象上失效，系统无法确保这点，所以，于其因为仅保留最新版定义导致旧对象的处理失败，允许多个版本定义并存是更好的解决方案。

但是，如果作者能确保新旧对象使用上毫无区别，也可以使用`System.__SingleVer__`标记这个类，它只会保留一个版本，最新的变更也会反应到这个版本中：

```lua
require "PLoop" (function(_ENV)
	__SingleVer__()
	class "A" (function(_ENV)
		function test(self)
			print("hi")
		end
	end)

	o = A()

	class "A" (function(_ENV)
		function test(self)
			print("hello")
		end
	end)

	o:test()   -- hello
	A():test() -- hello
end)
```

如果**PLoop**运行在单线程平台，而且整个使用场景相对简单，不会出现多版本冲突的话，也可以指定全平台使用单版本：

```lua
PLOOP_PLATFORM_SETTINGS = { CLASS_NO_MULTI_VERSION_CLASS = true }

require "PLoop" (function(_ENV)
	class "A" (function(_ENV)
		function test(self)
			print("hi")
		end
	end)

	o = A()

	class "A" (function(_ENV)
		function test(self)
			print("hello")
		end
	end)

	o:test()   -- hello
	A():test() -- hello
end)
```

当使用`__Sealed__`锁定类后，我们就不能在重新定义它，通常**PLoop**提供的类都已经锁定，也可以通过继承来扩展使用。


## 扩展类的方法

即便当类被锁定后，我们也可以为类提供新的方法来扩展它。添加方法并不会修改类的定义，所以，所有的对象都可以使用扩展出的方法。

```lua
require "PLoop" (function(_ENV)
	__Sealed__()
	class "A" (function(_ENV)
		function test(self)
			print("hi")
		end
	end)

	o = A()

	function A:test2()
		print("hello")
	end

	o:test2()   -- hello
end)
```

我们可以在定义新方法使用各种特性，比如申明方法为静态方法等，指定验证方法等：

```lua
require "PLoop" (function(_ENV)
	__Arguments__{ Callable }
	function List:Replace(rep)
		for i, v in ipairs(self) do
			self[i] = rep(v)
		end
		return self
	end

	-- 1,4,9,16,25,36,49,64,81,100
	print(List(10):Replace("x=>x^2"):Join(","))
end)
```

我们可以为超类或者接口扩展新的方法，那么继承或者扩展它们的子类的对象都可以获得新的处理功能。另外，结构体类型不支持这种扩展方法，因为会将不可变类型转换为可变类型，这对已经锁定的结构体类型而言，是不被允许的，很多系统的自动优化都基于此，目前没有机制也很难去对应这种转换。


## 接口(interface)

如果说，类是对具有一组特征和功能的对象的抽象，那么接口(interface)是对功能的抽象，这是**PLoop**的多继承的系统的重要部分，一个类只能有一个超类，但它可以扩展任意数量的接口，接口本身也可以扩展任意数量的其他接口。

接口同样可以定义对象方法和元表方法，这些可以被扩展它们的类的对象使用。和静态语言不同，**PLoop**的接口并非仅用于申明方法，接口本身是功能的载体，它可以提供具体的实现，也可以仅申明方法，然后由子接口或子类实现。

接口和类最大的区别在于，接口无法用于构建对象，因为它们只是功能的抽象，而不是实体的抽象。接口没有构造体方法，相对的，它具有一个初始化方法，使用`__init`或者接口名定义，初始化方法只能接受到被类构造完成后的对象，用于进行针对该接口的初始化操作：

``` lua
require "PLoop" (function(_ENV)
	interface "IScore" (function(_ENV)
		function IncrScore(self, count)
			self.score = self.score + count
		end

		function GetScore(self)
			return self.score
		end

		function __init(self)
			self.score = 0
			print("初始化成绩服务")
		end

		function __dtor(self)
			self.score = nil
			print("销毁成绩数据")
		end
	end)

	interface "IName" (function(_ENV)
		function SetName(self, name)
			self.name = name
		end

		function GetName(self)
			return self.name
		end

		function __init(self)
			print("初始化姓名服务")
		end

		function __dtor(self)
			self.name = nil
			print("销毁姓名数据")
		end
	end)

	class "Student" (function(_ENV)
		extend "IName" "IScore"

		function __ctor(self, name)
			self:SetName(name)
			print("初始化学生数据")
		end

		function __dtor(self)
			print("销毁学生数据")
		end
	end)

	-- 初始化学生数据
	-- 初始化姓名服务
	-- 初始化成绩服务
	ann = Student("Ann")
	ann:IncrScore(100)

	-- Ann	->	100
	print(ann:GetName(), "->", ann:GetScore())

	-- 销毁成绩数据
	-- 销毁姓名数据
	-- 销毁学生数据
	ann:Dispose()
end)
```

类似`inherit`，我们使用`extend "xxx"`的形式来扩展接口，名字会由环境尝试从自身，命名空间，基础环境重获取，多个接口可以写在一个`extend`语句里。`Student`扩展了`IName`和`IScore`接口，在走完`Person`的构造体后，它们的的初始化方法按照扩展次序被调用，初始化方法是每个接口特有的，不存在覆盖，仅由系统根据顺序依次访问。

对象构造时，类构造体最先被调用，之后才是接口的初始化，而接口析构的顺序和初始化时的顺序相反，类的析构是先子类后超类的方式。

通常，接口的名字以`I`开始，但这不是强硬规定，只是推荐。

如果应该由子类实现的方法， 可以用`System.__Abstract__`特性描述，这样做的好处是，覆盖了该方法的子类，不需要也不能使用`super`关键字去访问超类的该方法，虽然看起来是缺少了功能，但实际上访问对象的方法等，都是走元表的`__index`处理，如果一个类的对象需要使用`super`，那么这个处理的逻辑会占用`__index`的一部分（**PLoop**使用了动态构建的技术，根据类的定义情况自动定义元表，而不是一个元表定义处理所有），如果一个类的对象无需使用`super`访问超类资源，系统是不需要定义这部分逻辑的，可以减少一定量的访问消耗。

```lua
require "PLoop"

PLoop(function(_ENV)
	interface "IName" (function(_ENV)
		__Abstract__()
		function SetName(self) end

		__Abstract__()
		function GetName(self) end
	end)

	class "Person" (function(_ENV)
		extend "IName"

		-- Error: attempt to index global 'super' (a nil value)
		function SetName(self, name) super[self]:SetName(name) end
	end)

	o = Person()

	-- Error: xxx.lua:16: attempt to index global 'super' (a nil value)
	o:SetName("Ann")
end)
```

可见，`super`并非是到处都可以用的，仅当子类（含子接口）覆盖了超类或者接口的方法后，才能使用`super`调用被覆盖的方法（注意，仅限于被覆盖的）。


### 接口的匿名类

我们无法通过接口直接构建对象，因为它们通常只是功能的抽象，并没有直接的实体与之对应。但针对一些处理，如果我们只是需要定义一个类扩展接口后即可使用，而不需要添加任何定义（接口定义的方法也可以由对象自己提供，并非一定需要类提供）。那么我们可以用``System.__AnonymousClass__`特性申明一个接口有匿名类，意思是这个接口被创建后，自动定义一个匿名类扩展这个接口，我们无法直接访问这个类，但当把接口当作类使用去构造对象时，我们实际是使用这个匿名类来构建，当然这个细节可以被忽略：

```lua
require "PLoop" (function(_ENV)
	__AnonymousClass__()
	interface "ITask" (function(_ENV)
		__Abstract__() function Process()
		end
	end)

	o = ITask{ Process = function() print("Hello") end }

	o:Process()
end)
```

接口的方法并不一定是由类实现，也可以是对象直接实现的方式，毕竟，只要定义同名字段，table自然就覆盖了`__index`的处理。因为是接口的匿名类，这个类自身没有定义，所以只提供初始化表的对象构造方式。类似上面这个例子。

但为了简化一些特殊情况，如果一个接口只定了一个抽象方法时（允许定义其他对象方法，但仅一个`__Abstract__`描述的方法），我们可以直接用函数作为对象构造参数：

```lua
require "PLoop"

PLoop(function(_ENV)
	__AnonymousClass__()
	interface "ITask" (function(_ENV)
		__Abstract__() function Process() end
	end)

	o = ITask(function() print("Hello") end)
	o:Process()
end)
```

这种情况下，系统很清楚，传入的函数是用于作为唯一的抽象方法`Process`的实现。

如果希望为所有接口提供匿名类，也可以调整平台设置（并不推荐这么做）：

```lua
PLOOP_PLATFORM_SETTINGS = { INTERFACE_ALL_ANONYMOUS_CLASS = true }

require "PLoop"

PLoop(function(_ENV)
	interface "ITask" (function(_ENV)
		__Abstract__() function Process() end
	end)

	o = ITask(function() print("Hello") end)
	o:Process()
end)
```


### 限定接口的扩展类

接口通常需要面向的对象具有某些特征，这些特征可有接口自行定义和实现，也可以指定这些对象必须继承的类（通常是对象的类的超类），这里可以在接口定义中使用`require`关键字:

```lua
require "PLoop" (function(_ENV)
	class "A" {}

	interface "IA" (function(_ENV)
		require "A"
	end)

	class "B" (function(_ENV)
		extend "IA" -- Error: Interface.AddExtend(target, extendInterface[, stack]) - the class must be A's sub-class
	end)
end)
```

注意，`interface`定义中使用的`require`和最开始的`require "PLoop"`是两个完全不同的东西，**PLoop**的关键字通常都关联与使用场景，`require`是仅`interface`定义场景使用的关键字。


## 事件(event)

对象可以使用事件(event)通知外界自身状态的变化，外界可以通过监听对象事件的方式来获知这些变化：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		-- 申明一个事件
		event "OnNameChanged"

		field { name = "anonymous" }

		function SetName(self, name)
			if name ~= self.name then
				-- Notify the outside
				OnNameChanged(self, name, self.name)
				self.name = name
			end
		end
	end)

	o = Person()

	-- 为对象绑定事件监听函数
	function o:OnNameChanged(new, old)
		print(("Renamed from %q to %q"):format(old, new))
	end

	-- Renamed from "anonymous" to "Ann"
	o:SetName("Ann")
end)
```

事件是一个资源类型，用于接口和类，申明事件使用`event`关键字，申明后，就可以用`事件名(对象，参数, ...)`的形式发起事件，注意，虽然这里看起来是函数调用，但这里的事件名对应的是事件实体。

事件的处理函数有两种定义形式和用途：

* 最终处理函数 - 上面的例子演示了最终处理函数的设定方法，同时只能有一个最终处理函数，通过`obj.事件名 = 函数`的形式设定。

* 可堆叠的处理函数 - 通常用于接口和类构造或初始化对象时，为它的事件绑定处理函数，一个对象的一个事件也可以有任意多的堆叠处理函数，通过 `obj.事件名 = obj.事件名 + 函数`来追加，通过`obj.事件名 = obj.事件名 - 函数`的形式来移除处理函数：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		event "OnNameChanged"

		field { name = "anonymous" }

		function SetName(self, name)
			if name ~= self.name then
				-- Notify the outside
				OnNameChanged(self, name, self.name)
				self.name = name
			end
		end
	end)

	class "Student" (function(_ENV)
		inherit "Person"

		local function onNameChanged(self, name, old)
			print(("Student %s renamed to %s"):format(old, name))
		end

		function Student(self, name)
			self:SetName(name)
			self.OnNameChanged = self.OnNameChanged + onNameChanged
		end
	end)

	o = Student("Ann")

	function o:OnNameChanged(name)
		print("My new name is " .. name)
	end

	-- Student Ann renamed to Ammy
	-- My new name is Ammy
	o:SetName("Ammy")
end)
```

实际上`self.OnNameChanged`是**System.Delegate**类生成的对象实体，它具有`__add`和`__sub`的元表方法，使它能用于和函数做加减来增加/减少处理函数。

堆叠的处理函数是按照追加的顺序被调用的，当堆叠的处理函数处理结束后，最终处理函数才会被调用。如果中间任何处理函数返回true，那么处理终止，不再调用后面的处理函数。

**System.Delegate**对象还具有一个`SetInitFunction`方法，用于设置初使处理函数，通常当我们需要阻止事件被触发时，可以用它设置一个返回true的函数，之后设置nil即可取消事件屏蔽：

```lua
self.OnNameChanged:SetInitFunction(function() return true end)
```


### 事件处理函数的特性使用

我们也可以在函数上使用各种特性，不过，因为特性一般会替换掉原函数，所以，一旦应用后，就无法被移除。

通常，我们只会对处理函数使用`__Async__`特性，使处理函数运作在协程中，便于异步操作。

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		event "OnNameChanged"

		function SetName(self, name)
			self.name = name
			OnNameChanged(self, name)
		end
	end)

	ann = Person()

	__Async__()
	function ann:OnNameChanged(new)
		print("Final:", coroutine.running(), new)
	end

	__Async__()
	ann.OnNameChanged = ann.OnNameChanged + function(self, new)
		print("Stack:", coroutine.running(), new)
	end

	-- Stack:    thread: 00B90ECC    Ann
	-- Final:    thread: 00B90ECC    Ann
	ann:SetName("Ann")
end)
```


### 监听事件处理函数的变更

Lua通常会用于各类平台，而事件发起很可能是由平台提供，我们需要在对象的事件有监听函数注册时，在平台上进行实际的事件注册，这包括两部分处理:

1. 当对象的事件处理函数列表变化时，我们需要知道列表是否为空，之后我们可以在平台上注册或反注册实际事件。

2. 当平台上的事件触发后，我们需要发起对象的事件。

```lua
require "PLoop" (function(_ENV)
	class "Frame" (function(_ENV)
		-- 这个特性是唯一提供给event的特性，用于处理类的
		-- 所有对象该事件的处理函数队列变更
		__EventChangeHandler__(function(delegate, owner, eventname, init)
			-- delegate是保存处理函数队列的对象，可以参考本章最后的介绍，
			-- 通常只有这里需要调用它的IsEmpty方法来判定是否需要注册到平台
			--
			-- owner是对象实体
			--
			-- eventname是事件名，便于对应到平台事件
			--
			-- init只在delegate创建时提供，值为true，其它时候nil
			if delegate:IsEmpty() then
				-- 没有处理函数，反注册，伪代码
				API.Unregister(owner, eventname)
			else
				-- 注册平台事件处理
				API.Register(owner, eventname, function(self, ...)
					-- 直接调用delegate即可，无需考虑事件，也可以直接用owner，避免问题
					delegate(owner, ...)
				end)
			end
		end)
		event "OnClick"
	end)
end)
```

`System.__EventChangeHandler__`特性是唯一用于**event**的特性，一般它绑定的处理对同平台所有事件都是一致的，可以自己封装成一个函数来使用。


### 静态事件

除了对象事件外，也允许创建用于类或接口的静态事件：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Static__()
		event "OnPersonCreated"

		function Person(self, name)
			OnPersonCreated(name)
		end
	end)

	function Person.OnPersonCreated(name)
		print("Person created " .. name)
	end

	-- Person created Ann
	o = Person("Ann")
end)
```


### 超类事件

一般来说，我们没有覆盖超类定义的事件的需求，但不排除这种场景，如果有这样需求，也可以使用超类对象调用的方式，来绑定超类事件的处理函数：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		-- 省略调用
		event "OnNameChanged"
	end)


	class "Student" (function(_ENV)
		inherit "Person"

		event "OnNameChanged"

		local function raiseEvent(self, ...)
			OnNameChanged(self, ...)
		end

		function Student(self)
			-- 注册超类事件的处理函数
			super[self].OnNameChanged = raiseEvent
		end
	end)
end)
```

注意，虽然同名，但超类事件和子类事件是完全不同的。当然，通常使用这种处理的场景很难出现，可以略过。


## 属性(Property)

通常我们使用对象的字段保存对象的状态，通常这么处理并没有什么问题，但是我们无法对字段的赋值进行校验，也无法跟随赋值完成后续的处理，特别一旦赋给字段后，我们无法通过`__index`和`__newindex`元表方法来跟踪。

**PLoop**提供了**property**资源来扩展这块功能。属性系统提供非常丰富的配置：访问函数，类型验证，数据变更处理，默认值，默认值工厂，索引器等等。首先先看下用法：

```lua
require "PLoop"

PLoop(function(_ENV)
	class "Person" (function(_ENV)
		property "Name" { type = String }
		property "Age"  { type = Number }
	end)

	o = Person{ Name = "Ann", Age = 10 }

	print(o.Name)-- Ann
	o.Name = 123 -- Error : the Name must be string, got number
end)
```

我们使用`property`关键字给`Person`类定义了两个属性`Name`和`Age`，在属性名必须跟一个table，里面含有属性的各种配置，这里通过`type`设置了属性类型，用于值的校验，后面可以看到为`Name`赋值数字，系统就抛出错误了。

属性配置表中的字段是大小写无视的，下面是完整的列表：

字段            |用途
:---------------|:-------------
auto            |是否自动绑定对方方法给属性的访问器，详见后面的例子
get             |访问器之一，读取属性值的函数，用法类似`value = get(obj)`，也可以设置为false，那么属性就不可读
set             |访问器之一，写入对象的属性值，用法类似`set(obj, value)`，也可以设置为false，那么属性不可写
getmethod       |字符串，设置读取属性值用的对象方法名，调用类似`value = obj[getmethod](obj)`，这样子类覆盖了该对象方法后，可以使用子类的方法来获取属性值
setmethod       |字符串，设置写入对象属性值的对象方法名，调用类似`obj[setmethod](obj, value)`，子类覆盖该对象方法后，将使用子类的方法来读取对象属性值
field           |真实用于保存属性值的字段，当get/set被设置时，无效，通常如果设置访问器，并且不设置field时，系统会自动使用类（接口）名和属性名拼接生成实际字段，通常推荐这样处理，配合之后的handler，event设置可以满足绝大多数情况
type            |属性值的类型，用于值得验证，可以通过平台设置得`TYPE_VALIDATION_DISABLED`关闭来提升性能
default         |属性的默认值，如果指定的是函数，那么这个函数将用作默认值的生成器，可以用于lazy loading
factory         |属性的默认值工厂函数，用于生成默认值
event           |指定对象属性值变更时触发的事件，如果指定为字符串，对应的事件会被自动创建
handler         |函数，用于处理对象的属性值变化，和event不同，这是类（接口）内部自己处理属性值变更的入口，通常和`field`联合使用
static          |布尔值，true时这个属性是静态属性
indexer         |布尔值，true时这个属性是索引器
throwable       |布尔值，true时会处理属性处理里面的`throw`异常处理
require         |布尔值，true时无法接受nil赋值

下面是各个配置的使用例子：


### 属性访问(get/set)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		field { __name = "anonymous" }

		property "Name" {
			get = function(self) return self.__name end,
			set = function(self, name) self.__name = name end,
		}
	end)

	print(Person().Name)
end)
```

### 指定方法名访问属性(getmethod/setmethod)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		field { __name = "anonymous" }

		function SetName(self, name)
			self.__name = name
		end

		function GetName(self)
			return self.__name
		end

		property "Name" {
			get = "GetName", -- or getmethod = "GetName"
			set = "SetName", -- or setmethod = "SetName"
		}
	end)

	print(Person().Name)
end)
```

### 错误抛出(throw)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		field { __name = "anonymous" }

		function SetName(self, name)
			if type(name) ~= "string" then
				throw("The name must be string")
			end
			self.__name = name
		end

		function GetName(self)
			return self.__name
		end

		property "Name" {
			get = "GetName", -- or getmethod = "GetName"
			set = "SetName", -- or setmethod = "SetName"
			throwable = true,
		}
	end)

	Person().Name = 123 -- Error: The name must be string
end)
```


### 内部字段和默认值(field & default)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		property "Name" { field = "__name", default = "anonymous" }
		property "Age"  { type = Number } -- the field'll be auto generated
	end)

	obj = Person()
	print(obj.Name, obj.__name) -- anonymous   nil
	obj.Name = "Ann"
	obj.Age  = 24

	-- __name	Ann
	-- _Person_Age	24
	for k, v in pairs(obj) do
		print(k, v)
	end
end)
```


### 默认值构造函数(default factory)

注意，如果属性的类型不是函数类型，那么可以使用`default`替代`factory`。`factory`引入是为了解决属性类型是函数时，系统无法决定给定的`default`函数是默认值，还是默认值工厂，所以引入`factory`来明确用法。

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		property "Age" { field = "__age", factory = function(self) return math.random(100) end }
	end)

	obj = Person()
	print(obj.Age, obj.__age) -- 81   81
	obj.Age = nil   -- so the factory will works again
	print(obj.Age, obj.__age) -- 88   88
end)
```


### 属性事件(event)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		property "Name" { type = String, event = "OnNameChanged" }
	end)

	o = Person { Name = "Ann" }

	function o:OnNameChanged(new, old, prop)
		print(("[%s] %s -> %s"):format(prop, old, new))
	end

	-- [Name] Ann -> Ammy
	o.Name = "Ammy"
end)
```


### 属性处理方法(handler)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		property "Name" {
			type = String, default = "anonymous",

			handler = function(self, new, old, prop)
				print(("[%s] %s -> %s"):format(prop, old, new))
			end
		}
	end)

	--[Name] anonymous -> Ann
	o = Person { Name = "Ann" }

	--[Name] Ann -> Ammy
	o.Name = "Ammy"
end)
```


### 静态属性(static)

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		__Static__()
		property "DefaultName" { type = String }

		property "Name" {
			type = String, default = function() return Person.DefaultName end,
		}
	end)

	Person.DefaultName = "noname"

	print(Person().Name) -- noname
end)
```


### 自动方法绑定(Auto-binding)

如果开启了自动绑定，当属性配置不提供get/set, getmethod/setmethod和field的场合，系统会检查属性所有者(类或接口)的对象方法，尝试获取匹配名字的方法，如果我们的属性名为`name`，那么:

* 系统尝试以下的名字：*setname*, *Setname*, *SetName*, *setName*，如果存在，将作为属性的`set`

* 系统尝试以下的名字： *getname*, *Getname*, *Isname*, *isname*, *getName*, *GetName*, *IsName*, *isname*，如果存在，将作为属性的`get`

有疑问的场合请不要使用这种方式简化配置

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		function SetName(self, name)
			print("SetName", name)
		end

		property "Name" { type = String, auto = true }
	end)

	-- SetName  Ann
	o = Person { Name = "Ann"}

	-- SetName  Ammy
	o.Name = "Ammy"
end)
```


### 超类属性调用(super)

覆盖超类属性后，我们可以使用超类对象调用的方式来使用超类的属性访问：

```lua
require "PLoop" (function(_ENV)
	class "Person" (function(_ENV)
		property "Name" { type = String }
	end)

	class "Student" (function(_ENV)
		inherit "Person"

		property "Name" {
			Set = function(self, name)
				super[self].Name = name
			end,
			Get = function(self)
				return super[self].Name
			end,
		}
	end)

	o = Student()
	o.Name = "Test"
	print(o.Name)   -- Test
end)
```


### 索引器属性(indexer)

索引器属性用于实现`obj.Item[key] = value`和`value = obj.Item[key]`的访问形式，通常用于作为读写代理：

```lua
require "PLoop" (function(_ENV)
	class "A" (function( _ENV )
		__Indexer__()
		property "Items" {
			set = function(self, idx, value)
				self[idx] = value
			end,
			get = function(self, idx)
				return self[idx]
			end,
			type = String,
		}
	end)

	o = A()

	o.Items[1] = "Hello"

	print(o.Items[1])   -- Hello
end)
```

索引器仅支持set/get, getmethod/setmethod, type和static这几个配置字段。除了给值限定类型外，我们也可以限定键的类型：

```lua
require "PLoop" (function(_ENV)
	class "A" (function( _ENV )
		__Indexer__(String)
		property "Items" {
			set = function(self, idx, value)
				self[idx] = value
			end,
			get = function(self, idx)
				return self[idx]
			end,
			type = String,
		}
	end)

	o = A()

	-- Error: the Items's key must be string, got number
	o.Items[1] = "Hello"
end)
```


### 属性的访问修饰(Get/Set Modifier)

除了在属性定义表中进行访问配置外，我们还有更进一步的访问修饰，这块相对复杂，而且使用场景较少，如果无法理解，可以略过。

在`System.PropertySet`枚举类型中，定义了写入属性时的访问修饰：

```lua
__Flags__() __Default__(0)
enum "System.PropertySet" {
	Assign      = 0,  -- 直接写入
	Clone       = 1,  -- 写入浅层复制值
	DeepClone   = 2,  -- 写入深层复制值
	Retain      = 4,  -- 需要调用旧值的析构方法销毁对象
	Weak        = 8,  -- 值需要使用weak保存的形式，即不做引用，值可以被Lua回收
}
```

在`System.PropertyGet`枚举类型中，定义了读取属性时的访问修饰：

```lua
__Flags__() __Default__(0)
enum "System.PropertyGet" {
	Origin      = 0,  -- 直接返回值
	Clone       = 1,  -- 返回值的浅层复制
	DeepClone   = 2,  -- 返回值的深层复制
}
```

访问修饰需要使用`System.__Set__`和`System.__Get__`特性设置：

```lua
require "PLoop" (function(_ENV)
	class "Data" (function(_ENV)
		extend "ICloneable"  -- 可复制类需要扩展的接口

		local _Cnt = 0

		-- 实现复制方法
		function Clone(self)
			return Data()    -- 测试用
		end

		function __dtor(self)
			print("销毁数据 " .. self.Index)
		end

		function __ctor(self)
			_Cnt = _Cnt + 1
			self.Index = _Cnt
		end
	end)

	class "A" (function(_ENV)
		__Set__(PropertySet.Clone + PropertySet.Retain)
		__Get__(PropertySet.Clone)
		property "Data" { type = Data }
	end)

	o = A()

	dt = Data()

	o.Data = dt
	print(dt.Index, o.Data.Index)  -- 1  3
	o.Data = nil   -- 销毁数据 2
end)
```


## 继承和优先级

**PLoop**的继承是多继承系统，即便接口也会提供一些功能资源可被继承。通常，我们只关注于对象具有哪些资源，而不会在意它们的实现，这属于类型自身确定的。

多继承系统中，当子类继承的超类和接口就有同名的资源时，就会产生冲突，那么就必须有一个确定的机制来选择一个特定的资源来继承，通常采取的是最近原则：

* 首先检查超类，超类如果本身具有或从它的超类继承，那么直接使用超类的同名资源

* 超类不具备，就检查扩展的接口，最后被继承的接口会被检查，只要获取到就直接返回

这些通常由系统自行判定，但我们还可以通过两个特性来干涉这个选择：

* 如果一个资源（对象方法，元表方法，属性，事件）被`System.__Abstract__`特性标记，那么这个资源的继承优先级最低，并且不可使用`super`访问这些资源。

* 如果一个资源被`System.__Final__`特性标记，那么这个资源的继承优先级最高。

例如：

```lua
require "PLoop" (function(_ENV)
	interface "IA" (function(_ENV)
		__Final__()
		function Test(self)
			print("Hello IA")
		end

		__Abstract__()
		function Test2(self)
			print("Hello2 IA")
		end
	end)

	class "A" (function(_ENV)
		extend "IA"

		function Test(self)
			print("Hello A")
		end

		function Test2(self)
			print("Hello2 A")
		end
	end)

	o = A()
	o:Test()  -- Hello IA
	o:Test2() -- Hello2 A
end)
```

`__Abstract__`和`__Final__`都并非单一用于管理继承优先级，比如`__Abstract__`标记的资源无法被`super`访问，因为通常这么标记的资源都只是申明，没有实际实现。而`__Final__`特性标记的资源也同样有特殊的用法：

```lua
require "PLoop" (function(_ENV)
	interface "IA" (function(_ENV)
		__Final__() function Test(self)
			print("Call Test of IA")

			-- 通过对象获取对象的类型，通过类型获取类自身定义（或继承的非final）的方法
			-- 然后执行它
			Class.GetNormalMethod(Class.GetObjectClass(self), "Test")(self)
		end
	end)

	class "A" { IA, Test = function(self) print("Call Test of A") end }

	o = A()

	-- Call Test of IA
	-- Call Test of A
	o:Test()
end)
```

通过这种方式，我们可以在最初就限制了该方法的调用，然后将细节工作交给子类的定义。


## 使用其他定义形式

### 使用字符串作为定义体

我们可能会根据情况生成定义体，**PLoop**允许使用字符串作为结构体，接口和类的定义体，实际就是将`function(_ENV)`和对应的`end`替换为字符串的开始和结束：

```lua
require "PLoop" (function(_ENV)
	class "A" [[
		property "Name" { default = "anonymous" }
	]]

	print(A().Name)
end)
```

### 使用表作为定义体

实际更常用的是table作为定义体：

```lua
require "PLoop" (function(_ENV)
	class "Person" {
		-- 定义静态事件，当值是true时
		OnPersonCreated = true,

		-- 定义对象事件，当值是false时
		OnNameChanged   = false,

		-- 定义属性，当值是可验证类型或table时
		Name = String,
		Age  = { type = Number, default = 0 },

		-- 定义对象方法
		SetName = function(self, name)
			-- 这里并不是事件调用，而是获得事件对应的
			-- System.Delegate对象，然后直接调用它
			self:OnNameChanged(name, self.Name)
			self.Name = name
		end,

		-- 数字索引和函数值表示定义构造体，也可以用键`__ctor`
		function (self, name)
			Person.OnPersonCreated(name)
			self.Name = name
		end,
	}

	interface "IScore" {
		Person,      -- 如果索引是数字，值是类，那么表明这个接口只能用于这个类的子类
		ICloneable,  -- 如果索引是数字，值是接口，那么表明是扩展这个指定接口
	}

	class "Student" {
		Person,      -- 如果索引是数字，值是类，那么表明是继承这个指定的类
		IScore,      -- 如果索引是数字，值是接口，那么表明是扩展这个指定接口
	}

	-- 我们可以使用扩展机制在table定义后再继续定义方法等
	function Student:SetScore(score)
	end
end)
```


## 泛型类和泛型接口

类似泛型模板，我们可以定义出泛型类和泛型接口：

```lua
require "PLoop" (function(_ENV)
	__Arguments__ { AnyType }
	class "Array" (function(_ENV, eletype)
		__Arguments__{ eletype * 0 }
		function __new(cls, ...)
			return { ... }, true
		end
	end)

	--Error: Usage: Anonymous([... as System.Integer]) - the 4th argument must be number, got string
	o = Array[Integer](1, 2, 3, "hi", 5)
end)
```

它们生成的匿名类和接口也可以被继承下去，它们只是普通的类和接口，使用上没有分别：

```lua
require "PLoop" (function(_ENV)
	__Arguments__ { AnyType }
	class "Array" (function(_ENV, eletype)
		__Arguments__{ eletype * 0 }
		function __new(cls, ...)
			return { ... }, true
		end
	end)

	__Arguments__ { AnyType } (AnyType)
	class "Queue" (function(_ENV, eletype)
		inherit (Array[eletype])
	end)

	__Arguments__{ AnyType }(AnyType)
	interface "IA" (function(_ENV)end)

	__Arguments__{ AnyType }(AnyType)
	interface "IB" (function(_ENV, eletype)
		extend (IA[eletype])
	end)

	class "B" { Queue[String], IB[String] }

	print(Class.IsSubType(B, Array))  -- true
	print(Interface.IsSubType(B, IA)) -- true
end)
```

这些生成的匿名类（接口）以及继承（扩展）它们的类（接口）都是泛型类（接口）的子类，所以，当我们使用`-Array`时，`B`可以作为它的值。


## System.Interface

**System.Interface**提供了访问接口的一组API（构建接口系统的API不会被介绍，将在进阶文档中详细讨论)

### GetExtends

获取接口所扩展的所有接口

* Params:
	* target        - 目标接口
* Return:
	* iter          - function, 迭代器
	* target        - 目标接口


### GetFeature

获取目标接口指定名字的资源，通常是属性或者方法

* Params:
	* target        - 目标接口
	* name          - string, 资源名
	* forobject     - boolean, 是否只获取对象资源
* Return:
	* type          - the array element's type


### GetFeatures

获取目标接口所有的资源

* Params:
	* target        - 目标接口
	* forobject     - boolean, 是否只获取对象资源
* Return:
	* iter          - function, 迭代器
	* target        - 目标接口


### GetMethod

获取目标接口的指定方法

* Params:
	* target        - 目标接口
	* name          - string, 方法名
	* forobject     - boolean, 是否只获取对象方法
* Return:
	* method        - function, 函数体
	* isstatic      - boolean, 静态方法时返回true


### GetMethods

获取目标接口的所有方法

* Params:
	* target        - 目标接口
	* forobject     - boolean, 是否只获取对象方法
* Return:
	* iter          - function, 迭代器
	* target        - 目标接口


### GetMetaMethod

获取目标接口的元表方法

* Params:
	* target        - 目标接口
	* name          - string, 元表方法名
	* forobject     - boolean, 是否只获取对象用元表方法
* Return:
	* method        - function，元表方法


### GetMetaMethods

获取目标接口的所有元表方法

* Params:
	* target        - 目标接口
	* forobject     - boolean, 是否只获取对象用元表方法
* Return:
	* iter          - function, 迭代器
	* target        - 目标接口


### GetRequireClass

获取目标接口所需的类型

* Params:
	* target        - 目标接口
* Return:
	 class          - 所需类型


### GetSubTypes

获取所有直接扩展了目标接口的接口或类

* Params:
	* target        - 目标接口
* Return:
	* iter          - function, 迭代器
	* target        - 目标接口


### GetSuperMethod

获取目标接口指定名字的超类方法

* Params:
	* target        - 目标接口
	* name          - string, 方法名
* Return:
	* method        - function, 超类方法


### GetSuperMetaMethod

获取目标接口指定名字的超类元表方法

* Params:
	* target        - 目标接口
	* name          - string, 元表方法名
* Return:
	* method        - function, 超类元表方法


### GetSuperFeature

获取目标接口的指定名字的超类资源

* Params:
	* target        - 目标接口
	* name          - string, 资源名
* Return:
	* feature       - 超类资源


### GetTemplate

获取目标接口的模板

* Params:
	* target        - 目标接口
* Return:
	* template      - 泛型接口


### GetTemplateParameters

获取目标接口创建时的参数

* Params:
	* target        - 目标接口
* Return:
	* ...           - 参数列表


### HasAnonymousClass

检查接口是否具有匿名类

* Params:
	* target        - 目标接口
* Return:
	* flag          - 如果目标接口具有匿名类，返回true


### IsAbstract

判定目标接口指定名字的方法，元表方法或资源名是否是抽象定义的

* Params:
	* target        - 目标接口
	* name          - 方法，元表方法或资源名
* Return:
	* flag          - 如果是抽象定义，返回true


### IsFinal

判定目标接口指定名字的方法，元表方法或资源名是否是最终定义的

* Params:
	* target        - 目标接口
	* name          - 方法，元表方法或资源名
* Return:
	* flag          - 如果是最终定义，返回true


### IsImmutable

判定接口是否不可变类型

* Params:
	* target        - 目标接口
* Return:
	* flag          - 永远返回true
	* isAlways   	- 永远返回true


### IsSealed

判定接口是否已锁定

* Params:
	* target        - 目标接口
* Return:
	* flag          - 锁定时返回true


### IsStaticMethod

判定目标接口的指定名称的方法是否是静态方法

* Params:
	* target        - 目标接口
	* name          - 方法名
* Return:
	* flag          - 是静态方法时返回true


### IsSubType

判定目标接口是否是另一个接口的子接口

* Params:
	* target        - 目标接口
	* extendIF      -接口
* Return:
	* flag          - 如果是子接口，返回true


### ValidateValue

验证一个对象是否扩展了目标接口

* Format: (target, value)
* Params:
	* target        - 目标接口
	* value         - 对象
* Return:
	* value         - 验证结果，非扩展返回nil，否则返回对象
	* errormsg      - 错误消息


### Validate

验证目标是否是接口

* Params:
	* target        - 目标
* Return
	* target        - 如果通过验证返回目标，否则返回nil


## System.Class

**System.Class**提供了用于获取类信息的API（创建类的API不再本章讨论，会在进阶文档中详细介绍）


### GetExtends

获取类所扩展的所有接口

* Params:
	* target        - 目标类
* Return:
	* iter          - function, 迭代器
	* target        - 目标类


### GetFeature

获取目标类指定名字的资源，通常是属性或者方法

* Params:
	* target        - 目标类
	* name          - string, 资源名
	* forobject     - boolean, 是否只获取对象资源
* Return:
	* type          - the array element's type



### GetFeatures

获取目标类所有的资源

* Params:
	* target        - 目标类
	* forobject     - boolean, 是否只获取对象资源
* Return:
	* iter          - function, 迭代器
	* target        - 目标类


### GetMethod

获取目标类的指定方法

* Params:
	* target        - 目标类
	* name          - string, 方法名
	* forobject     - boolean, 是否只获取对象方法
* Return:
	* method        - function, 函数体
	* isstatic      - boolean, 静态方法时返回true


### GetMethods

获取目标类的所有方法

* Params:
	* target        - 目标类
	* forobject     - boolean, 是否只获取对象方法
* Return:
	* iter          - function, 迭代器
	* target        - 目标类


### GetMetaMethod

获取目标类的元表方法

* Params:
	* target        - 目标类
	* name          - string, 元表方法名
	* forobject     - boolean, 是否只获取对象用元表方法
* Return:
	* method        - function，元表方法


### GetMetaMethods

获取目标类的所有元表方法

* Params:
	* target        - 目标类
	* forobject     - boolean, 是否只获取对象用元表方法
* Return:
	* iter          - function, 迭代器
	* target        - 目标类


### GetNormalMethod

获取目标类的指定名字的普通对象方法（含继承的非Final方法），以便在被申明为Final的方法中使用：

* Params:
	* target        - 目标类
	* name          - 方法名
* Return:
	* function      - 方法


### GetNormalMetaMethod

获取目标类的指定名字的普通元表方法（含继承的非Final方法），以便在被申明为Final的元表方法中使用：

* Params:
	* target        - 目标类
	* name          - 元表方法名
* Return:
	* function      - 元表方法


### GetNormalFeature

获取目标类的指定名字的普通资源（含继承的非Final方法），以便在被申明为Final的资源中使用：

* Params:
	* target        - 目标类
	* name          - 资源名
* Return:
	* function      - 资源


### GetObjectClass

获取对象的类

* Params:
	* target        - 对象
* Return:
	* class         - 类


### GetObjectSource

获取对象创建的代码位置，需给对象的类开启`System.__ObjectSource__`特性

* Params:
	* target        - the target object
* Return:
	* source        - where the object is created


### GetSubTypes

获取所有直接扩展了目标类的类

* Params:
	* target        - 目标类
* Return:
	* iter          - function, 迭代器
	* target        - 目标类


### GetSuperClass

获取目标类的超类

* Params:
	* target        - 类
* Return:
	* super         - 超类


### GetSuperMethod

获取目标类指定名字的超类方法

* Params:
	* target        - 目标类
	* name          - string, 方法名
* Return:
	* method        - function, 超类方法


### GetSuperMetaMethod

获取目标类指定名字的超类元表方法

* Params:
	* target        - 目标类
	* name          - string, 元表方法名
* Return:
	* method        - function, 超类元表方法


### GetSuperFeature

获取目标类的指定名字的超类资源

* Params:
	* target        - 目标类
	* name          - string, 资源名
* Return:
	* feature       - 超类资源


### GetSuperObjectStyle

是否允许类的对象使用超类对象调用方式，类似`super[obj].Name = "ANN"`

* Params:
	* target        - 目标类
* Return:
	* usesuper      - 当对象可以使用超类对象调用时，返回true


### GetTemplate

获取目标类的模板

* Params:
	* target        - 目标类
* Return:
	* template      - 泛型类


### GetTemplateParameters

获取目标类创建时的参数

* Params:
	* target        - 目标类
* Return:
	* ...           - 参数列表


### IsAbstract

判定目标类指定名字的方法，元表方法或资源名是否是抽象定义的

* Params:
	* target        - 目标类
	* name          - 方法，元表方法或资源名
* Return:
	* flag          - 如果是抽象定义，返回true


### IsFinal

判定目标类指定名字的方法，元表方法或资源名是否是最终定义的

* Params:
	* target        - 目标类
	* name          - 方法，元表方法或资源名
* Return:
	* flag          - 如果是最终定义，返回true


### IsImmutable

判定类是否不可变类型

* Params:
	* target        - 目标类
* Return:
	* flag          - 永远返回true
	* isAlways   	- 永远返回true


### IsObjectAttributeEnabled

是否为目标类的对象启用对象特性，这样这些对象被构建时，对象特性可以被使用，通常类需要使用`System.__ObjectAttr__`特性

* Params:
	* target        - 目标类
* Return:
	* flag          - 如果可以使用对象特性，那么返回true


### IsObjectFunctionAttributeEnabled

是否可以在为类的对象赋予函数时，使用函数特性进行修饰，通常类需要使用`System.__ObjFuncAttr__`特性描述

* Params:
	* target        - 目标类
* Return:
	* flag          - 如果允许对象直接赋予的函数使用特性，返回true


### IsObjectSourceDebug

类是否会记录对象的创建位置

* Params:
	* target        - 目标类
* Return:
	* flag          - 如果类的对象的创建位置会被记录，返回true


### IsObjectType

判定对象的类是指定的类型，或者对象的类的符类是指定的类型

* Params:
	* target        - 目标类
	* type          - 接口或类
* Return:
	* flag          - 如果对象由指定类型派生，返回true


### IsMethodAutoCache

判定对象是否会自行缓存自己访问过的方法，通常类需要使用`System.__AutoCache__`特性描述，这样可以有限的提升运行效率

* Params:
	* target        - 目标类
* Return:
	* flag          - 对象会自动缓存方法时，返回true


### IsNilValueBlocked

类的对象是否不能被读取不存在的字段，通常类使用`System.__NoNilValue__`特性描述

* Params:
	* target        - 目标类
* Return:
	* flag          - 当对象不能被读取不存在的字段时，返回true


### IsRawSetBlocked

类的对象是否不能写入不存在的字段，通常类使用`System.__NoRawSet__`特性描述

* Params:
	* target        - 目标类
* Return:
	* flag          - 当对象不能被写入不存在的字段时，返回true


### IsSealed

判定类是否已锁定

* Params:
	* target        - 目标类
* Return:
	* flag          - 锁定时返回true


### IsSingleVersion

判定类是否是单版本类

* Params:
	* target        - 目标类
* Return:
	* flag          - 如果目标类只保留一个版本，那么返回true


### IsStaticMethod

判定目标类的指定名称的方法是否是静态方法

* Params:
	* target        - 目标类
	* name          - 方法名
* Return:
	* flag          - 是静态方法时返回true


### IsSubType

判定目标类是否是其他类（接口）的子类

* Format:
	(target, extendIF)
	(target, supercls)
* Params:
	* target        - 目标类
	* extendIF      - 扩展的接口
	* supercls      - 超类
* Return:
	* flag          - 当目标类是指定类型的子类时，返回true


### ValidateValue

验证一个对象是否由了目标类派生

* Format: (target, value)
* Params:
	* target        - 目标类
	* value         - 对象
* Return:
	* value         - 验证结果，非扩展返回nil，否则返回对象
	* errormsg      - 错误消息


### Validate

验证目标是否是类

* Params:
	* target        - 目标
* Return
	* target        - 如果通过验证返回目标，否则返回nil


## System.Event

**System.Event**提供了访问事件信息的一组API，通常可以通过类（接口）的`GetFeature`API拿取到事件对象，之后可以传入下面的API获取信息：


### IsStatic

事件是否时静态

* Params:
	* target        - 事件
* Return
	* flag          - 事件是静态事件时，返回true


### Invoke

启动一个事件，并给定参数

* Format: (target[, object], ...)
* Params:
	* target        - 事件
	* object        - 目标对象
	* ...           - 参数


### Validate

验证实体是否是事件

* Params:
	* target        - 实体
* Return:
	* target        - 如果目标是事件，返回目标，否则nil


下面是一个使用用例：

```lua
require "PLoop"(function(_ENV)
	class "A" (function(_ENV)
		__Static__() event "OnObjectCreated"

		event "OnNameChanged"
	end)

	for name, feature in Class.GetFeatures(A) do
		if Event.Validate(feature) then
			print(name, Event.IsStatic(feature))
		end
	end
end)
```


## System.Property

**System.Property**提供了一组访问属性信息的API，通常属性实体由类（接口）的`GetFeature`API获取：


### GetField

获取属性的实际字段

* Params:
	* target        - 属性
* Return
	* string        - 字段


### IsGetClone

读取属性值时是否返回的是浅层复制

* Params:
	* target        - 属性
* Return
	* flag          - 如果返回浅层复制返回true


### IsGetDeepClone

读取属性值时是否返回的是深层复制

* Params:
	* target        - 属性
* Return
	* flag          - 如果返回深层复制返回true


### IsIndexer

判断属性是否是索引器，类似`obj.prop[xxx] = xxx`

* Params:
	* target        - 属性
* Return
	* flag          - 属性是索引器返回true


### IsReadable

属性值可读

* Params:
	* target        - 属性
* Return
	* flag          - 属性值可读时返回true


### IsSetClone

写属性值时，是否写入的是浅层复制

* Params:
	* target        - 属性
* Return
	* flag          - 写入值的浅层复制时返回true


### IsSetDeepClone

写属性值时，是否写入的是深层复制

* Params:
	* target        - 属性
* Return
	* flag          - 写入值的深层复制时返回true


### IsRetainObject

值替换时，旧值是否需要被析构

* Params:
	* target        - 属性
* Return
	* flag          - 如果需要析构旧值，返回true


### IsStatic

是否是静态属性

* Params:
	* target        - 属性
* Return
	* flag          - 属性是静态时返回 true


### IsThrowable

属性是否会抛出异常

* Params:
	* target        - 属性
* Return
	* flag          - 属性处理可以抛出异常返回true


### IsWeak

属性值是否采用weak table的保存方式

* Params:
	* target        - 属性
* Return
	* flag          - 属性值采用弱表保存时返回true


### IsWritable

属性值是否可写

* Params:
	* target        - 属性
* Return
	* flag          - 如果可以写入属性值返回true


### GetDefault

获取属性的默认值

* Params:
	* target        - 属性
* Return
	* default       - 默认值


### GetIndexType

获取索引器的键的类型

* Params:
	* target        - 属性
* Return
	* type          - 索引器键的类型

```lua
require "PLoop" (function(_ENV)
	class "A" (function(_ENV)
		__Indexer__(String)
		property "Item" {
			get = function() end,
			set = function() end,
			type = Number
		}
	end)

	-- System.String
	print(Property.GetIndexType(Class.GetFeature(A, "Item")))
end)
```


### GetType

获取属性值的类型

* Params:
	* target        - 属性
* Return
	* type          - 属性值的类型


### Validate

验证目标是否是一个属性实体

* Params:
	* target        - 目标
* Return
	* target        - 如果是属性实体返回目标，否则返回nil


## System.Delegate

`System.Delegate`用于作为事件的处理函数列表，它提供了列表调用的整套机制，这个类也提供了常用的方法(self参数省略)：


### CopyTo

将自己的的处理列表复制给另一个处理对象：

* Params:
	* target        - 目标


### Invoke

调用自身保存的处理列表，可以给定一组参数传递下去

* Params:
	* ...           - 参数组


### IsEmpty

检查自身是否不包含任何处理

* Params:

* Return
	* flag         - 如果代表实体不含任何处理函数，返回true


### SetInitFunction

设置最初调用函数，通常可用`return true`作为函数体，用于屏蔽该对象的对应事件处理

* Params
	* func         - 最初调用函数

### SetFinalFunction

设置最终调用函数，通常直接使用`obj.事件名 = 函数`的方式进行设置

* Params
	* func         - 最终调用函数

