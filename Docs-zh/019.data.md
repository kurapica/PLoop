# 数据操作 System.Data

`System.Data`库提供了两块功能:

* 面向数据库的抽象数据实体框架(Abstract Data Entity Framework)，它提供了代码数据类型和数据库表之间的映射，尽可能的简化了数据库操作，能有效减少程序中SQL的使用，避免代码重构困难等问题。

* 面向缓存的基础类库，因为缓存数据库的使用都有各自的特色，缓存基础类和接口只申明了通用的方法。


## 目录

* [数据库操作示例](#数据库操作示例)
* [数据库上下文和数据实体](#数据库上下文和数据实体)
	* [System.Data.IDataContext](#systemdataidatacontext)
	* [System.Data.IDataEntity](#systemdataidataentity)
	* [表字段的映射](#表字段的映射)
	* [数据的查询](#数据的查询)
	* [数据的创建](#数据的创建)
	* [数据的更新](#数据的更新)
	* [数据的删除](#数据的删除)
	* [数据类型的自动转换](#数据类型的自动转换)
	* [DBNull](#dbnull)
	* [数据视图](#数据视图)
* [特定数据库的对接](#特定数据库的对接)
* [缓存数据类库](#缓存数据类库)
	* [System.Data.ICache](#systemdataicache)
	* [System.Data.DataEntityCache](#systemdatadataentitycache)
* [应用](#应用)


## 数据库操作示例

首先是**PLoop**的数据实体架构下，操作数据库的示例（伪代码，数据定义稍后介绍）：

```lua
require "PLoop.System.Data"  -- PLoop库会被依赖加载

PLoop(function(_ENV)
	import "System.Data"

	-- 插入数据
	function AddUser(name, telno)
		-- UserDataContext是对应用户处理的数据库上下文
		with(UserDataContext())(function(ctx)
			-- ctx.Transaction是上下文提供的数据库事务
			-- 更新数据，必须启动一个事务
			with(ctx.Transaction)(function(trans)
				-- ctx.Users对应数据库user表的数据集合
				-- Add用于添加一行数据
				local user   = ctx.Users:Add{
					name     = name,
					telno    = telno,
					register = Date.Now,
				}

				-- 就数据修改提交到数据库
				ctx:SaveChanges()

				-- id 对应数据库的自增字段，所以不用设置
				-- 保存数据到数据库后，id会读取到数据库
				-- 为它自动生成的值，我们可以直接使用
				print("新用户ID", user.id)
			end)
		end)
	end

	-- 读取和更新数据
	function UpdateUser(id, name, telno)
		with(UserDataContext())(function(ctx)
			-- 一般更新数据时，查询都是用主键或索引去查询，可以直接
			-- 用query table的方式查询，查询结果是一个List对象。
			-- 我们只需要用First获取第一个对象即可
			local user = ctx.Users:Query{ id = id }:First()
			if not user then return end

			with(ctx.Transaction)(function(trans)
				-- 更新数据，需要先锁定数据行
				user         = ctx.Users:Lock{ id = id }:First()
				user.name    = name
				user.telno   = telno

				ctx:SaveChanges()
			end)
		end)
	end

	-- 删除数据
	function UpdateUser(id, name, telno)
		with(UserDataContext())(function(ctx)
			with(ctx.Transaction)(function(trans)
				local user   = ctx.Users:Lock{ id = id }:First()

				if not user then
					-- 不打算提交变更时，需要主动回滚
					-- 不然在关闭事务时会做提交处理
					return trans:Rollback()
				end

				-- 标记自己为删除
				user:Delete()

				ctx:SaveChanges()
			end)
		end)
	end
end)
```


## 数据库上下文和数据实体

框架从三个层面将数据库和数据处理映射：

* **数据库**映射**数据库上下文**(DataBase <-> DataContext)，通常一次数据库操作中，我们需要读写多个数据库表，我们需要一个管理器，管理在这个过程中创建的数据对象，并追踪它们所有的修改，并能将所有修改按数据依赖关系先后提交到数据库。

	从代码的角度看，我们将**数据库表**映射为**数据集合**，数据库表含有多行数据，每行数据对应一个数据对象，所以，我们可以认为数据库表就是数据对象的集合，我们搜索数据，是从集合中获取满足条件的对象，增加，删除和修改都是对集合数据的操作。
	
	为此，**PLoop**提供了**数据库上下文类**，每个数据库上下文会包含多个数据集合，它并不需要包含数据库所有的表，通常只需要包含相关联的几张表。

* **数据库表结构**映射**数据实体类**(DataTable <-> EntityClass)，数据库表结构是固定的，用于申明字段类型，可以很好的和具有属性的类对应。

	注意，这里是指数据库表的结构，不是指数据库表（和它包含的行）。
	
	通常我们在数据库上下文类中会定义一个数据实体类，系统会自动将生成对应的**数据集合**的属性，集合的元素就是就是这个数据实体类，之后我们就可以通过**数据集合**操作数据。
	
	在上面的例子中，`UserDataContext.User`是user表结构对应的实体类(虽然不会直接使用，但生成的user对象都是用这个类生成的)，而`UserDataContext.Users`是user表对应的数据集合，也是我们用来增删查改的入口。请区分这两个概念。

* **数据库表字段**和**属性**(DataField <-> Property)，数据库表字段可以和类属性一一对应，但需要注意，字段类型和属性类型不能等同，从数据库读取的数据和写入数据库时都需要进行数据转换，通常这由系统自动完成。

我们将字段映射为属性，每行数据映射为数据实体类的对象。而每个数据库表对应于数据库上下文对象持有的一个数据集合，从这些数据集合读取的数据对象，他们的修改都可以被这些集合所属的上下文对象追踪，这样，就可以在`SaveChanges`调用时一次性提交到数据库。

注意，和C#的Data Entity Framework不同，这里的数据库上下文并不会缓存查询结果，所以，不能长期使用一个上下文对象，处理结束后，就需要关闭。

那么，我们正式实现上面例子中用到的UserDataContext上下文类:

```lua
require "PLoop.System.Data"

PLoop(function(_ENV)
	import "System.Data"

	-- 映射数据库，因为数据库链接是可变的，通常通过配置表设置
	-- 这里只需要申明数据库上下文即可
	__DataContext__()
	class "UserDataContext" (function(_ENV)
		-- 映射数据库表和类
		__DataTable__{
			-- name申明数据库表名，如果不输入，即类名
			name         = "user",

			-- 必须提供主键和索引信息，至少提供主键，有利于系统优化
			-- 和一些特殊的功能提供
			-- 索引可以有多组，所以，indexes的值是数组结构体类型
			indexes      = {
				-- 主键申明，因为主键可能是多个，fields的值同样是数组结构体
				-- primary表明这个索引是主键
				{ fields = { "id" },   primary = true },
				-- unique表明这两个索引都是unique的
				{ field  = { "name" },  unique = true },
				{ fields = { "telno" }, unique = true },
			}
		}
		class "User" (function(_ENV)
            -- 映射表字段和类属性，autoincr表明这是数据库字段是自增的
            -- 可以用name指定字段名，默认就是属性名
			__DataField__{ autoincr = true }
			property "id"           { type = NaturalNumber }

			__DataField__{ notnull = true, unique = true }
			property "name"         { type = String }

			__DataField__{ notnull = true, unique = true }
			property "telno"        { type = String }
		end)

		__DataTable__{
			name         = "login",

			indexes      = {
				{ fields = { "id", "login" }, primary = true },
			}
		}
		class "Login" (function(_ENV)
			__DataField__{ autoincr = true }
			property "id"           { type = NaturalNumber }

			__DataField__{ notnull = true }
			property "login"        { type = Date }

			-- 外键关联，属性的类型User指明了关联的主表是User
			-- foreign中，map定义了外键和主键的映射，
			-- 键是外键的字段（非属性名，虽然通常属性名和字段名一致），
			-- 值是主表的主键字段（非属性名）
			-- 定义后，通过Login的对象，可以直接使用`login.user`拿到对应的User对象
			--
			-- foreign的link定义是为主表User增加了一个新的属性`LoginTimes`，
			-- 因为作为外键的id不是unique的（还有一个login字段），
			-- 所以主表类的对象访问`LoginTimes`时，将会去拿取自身的所有登陆数据，
			-- 这些数据转换为`Login`类的对象，然后保存在List中
			-- 例如`user.LoginTimes:Each(function(lg) print(lg.login) end)`
			-- name指明了为User增加的属性名，
			-- order指明了对象列表的排序，按login字段使用desc排序
            -- 更详细的说明在后面的小节中
			__DataField__{
				foreign     = {
					map     = { id = "id" },
					link    = { name = "LoginTimes", order = { name = "login", desc = true }
				}
			}
			property "user"   { type = User }
		end)
	end)
end)
```

为了使用这个上下文，还需要在创建时指定数据库连接：

```lua
ctx = UserDataContext()

ctx.Connection = MySQLConnection {
	host        = "127.0.0.1",
	port        = 3306,
	database    = "TestDB",
	user        = "root",
	password    = "xxxxxx",
}
```

`MySQLConnection`的实现可以在[NgxLua][]找到，用于[Openresty][]服务器。通常也可以将数据库连接构造定义在上下文类的构造体方法中。


### System.Data.IDataContext

当使用`__DataContext__`特性标记类时，这个类会自动扩展`IDataContext`接口，这个接口扩展了`IAutoClose`，可以配合`with`关键字使用。这个接口提供了数据库上下文类的属性和方法：


属性                     |参数                         |描述
:------------------------|:---------------------------|:--------------------------
Connection               |System.Data.IDbConnection   |读写数据库连接
Transaction              |System.Data.IDbTransaction  |只读，用于获取正在使用的或者新建的数据库事务



方法                     |参数                                                           |描述
:------------------------|:-------------------------------------------------------------|:------------------------------
Open                     |                                                              |打开数据库连接
Close                    |                                                              |关闭数据库连接
SaveChanges              |                                                              |保存数据修改
Query                    |sql: String, ... : Any * 0                                    |使用格式化字符串和参数生成sql后执行请求，结果作为List返回
Execute                  |sql: String, ... : Any * 0                                    |使用格式化字符串和参数生成sql后执行处理，返回处理结果
QueryAsView              |viewcls:-System.Data.IDataView, sql: String, ... : Any * 0    |使用格式化字符串和参数生成sql后执行处理，返回的每行数据使用指定的视图类生成对象后，保存在List中返回
QueryView                |viewcls:-System.Data.IDataView, ... : Any * 0                 |使用视图类自带的查询格式化字符串，和参数一起生成sql后执行请求，请求结果的每行数据使用视图类生成对象后，保存在List中返回


`Query`和`Execute`都用于支持纯SQL，因为对于一些复杂的查询来说，使用SQL比提供复杂的函数链式调用要来的简单和直接，不过直接使用SQL查询的结果，不利于代码直接使用（例如日期字符串需要转换为日期对象才能正确使用等）。

```lua
-- 伪代码，无法直接执行
local ctx = UserDataContext()
ctx.Connection = MySQLConnection{...}

ctx:Open()

local result = ctx:Query("SELECT * FROM user where id = %d", 100)
result:Each("u=>print(u.name)")

-- table会使用","拼接，这个机能是由MySQLConnection处理，并非抽象数据实体框架提供
result = ctx:Query("SELECT * FROM user where id in (%s)", { 1, 2, 3, 4, 5 })

ctx:Close()
```

`Query`和`Execute`的区别在于，`Query`的结果是一个含所有数据行的List（哪怕没有结果，也会返回一个空List)，而`Execute`会将数据库返回的结果直接返回给调用者。

这两个API更多是底层框架使用，因为它的返回结果是普通的Lua数据，并没有转换为对应类的对象，上下文对象也无法跟踪这些数据的变更。我们实际会使用数据集合查询的方式来替代SQL的直接使用，确保能按类生成对象，并进行跟踪。

`QueryAsView`和`QueryView`的使用，将在稍后介绍。


### System.Data.IDataEntity

`__DataTable__`特性标记的类，会自动扩展`IDataEntity`接口，表明它是数据库特定表的结构的映射。

这个类的对象被称为数据实体，是对数据库表的每行数据的封装。`__DataTable__`特性用于将类和指定的数据库表（的结构）绑定，所以，它只关心表的设置，它只接受`DataTableSetting`结构的值，下面是具体的定义：

```lua
-- 索引结构的定义，通常每个表都含有多组索引，用于优化查询，映射时，需要
-- 提供索引信息，有助于系统进行优化
struct "DataTableIndex" {
	-- 索引名称，框架并不在意索引名称，实际系统内并不需要使用它
	-- 但如果计划使用Code First的设计模式，提供它有助于对数据库
	-- 的表进行自动维护
    { name = "name",        type = String },

    -- 该索引是否是unique唯一的
    { name = "unique",      type = Boolean },

    -- 该索引是否是全文索引
    { name = "fulltext",    type = Boolean },

    -- 该索引是否是主键
    { name = "primary",     type = Boolean },

	-- 索引字段列表，顺序很关键，特别Code First设计时，这里
	-- 输入的是数据库表字段，不是属性名（虽然通常采取一致的设计）
    { name = "fields",      type = struct { String } },
}

-- 数据库表的设定，这个作为__DataTable__的参数
struct "DataTableSetting" {
	-- 表名，如果省略，使用类名作为表名
    { name = "name",        type = String },

    -- 索引数组，元素类型是上面定义的DataTableIndex
    { name = "indexes",     type = struct { DataTableIndex } },

	-- 请记住，这里定义的类是映射数据库表的结构，并非映射数据库表本身，通常，数据实体类
	-- 需要定义在数据库上下文类中，作为下属类型保存，而数据库上下文会基于这个实体类，
	-- 为自己添加一个属性，名字通常是 数据实体类名+"s"。
	-- 访问这个属性后，会返回一个数据集合，通过数据集合我们可以读取，添加数据实体，
	-- 以此来操作数据库表的数据。例如上面例子中的`ctx.Users`就是一个数据集合，对应的
	-- 数据实体类是 UserDataContext.User 类。
	--
	-- 如果有特别需求，可以使用collection指定数据集合的属性名，覆盖默认方式，不过通常
	-- 没有这个必要。
    { name = "collection",  type = String },

	-- 数据库表使用的引擎，设置对框架没有用途，通常用于Code First设计模式下，
	-- 提供数据库表构建时的引擎设置
    { name = "engine",      type = String },
}
```

`DataTableSetting`的成员没有必须项，不过能提供索引还是请尽可能提供索引信息。系统可以根据索引信息进行优化。

`IDataEntity`提供了不少可用方法，不过对非框架的部分，通常只需要使用`Delete`方法：

方法                    |描述
:-----------------------|:-------------------
Delete                  |将自身标记为删除，之后由上下文对象一并提交给数据库


### 表字段的映射

表结构由字段及字段类型组成，对应到数据实体类的属性名和属性类型。并且唯有通过属性的内部处理，系统才能清楚的了解数据实体对象的变更，注意，为数据实体对象定义映射到字段的属性时，请仅申明属性类型，不要设置`Get/Set`访问器等，应该将这些处理留给系统。

定义映射字段的属性时，我们需要使用`System.Data.__DataField__`特性来标记属性（数据实体类可以定义自用的属性，并非都需要映射到数据库表字段）。类似`__DataTable__`特性，它也需要一个特定结构体类型`System.Data.FieldSetting`的参数，这个参数需要提供字段的相关信息：

```lua
-- 字段排序 
-- { name = "id", desc = true } -> "ORDER BY id DESC"
struct "QueryOrder" {
	{ name = "name",   type = String, require = true },
	{ name = "desc",   type = Boolean },
}

-- 字段排序数组 
-- { { name = "id", desc = false }, { name = "age", desc = true} } -> "ORDER BY id, age DESC"
struct "QueryOrders" { String + QueryOrder }

-- 数据库值类型和程序值类型的转换器，通常系统会针对特定类型提供
-- 默认的转换器，例如Date<->DATETIME, Boolean<->TINYINT
-- 如果不需要覆盖默认行为，并不需要在字段中指定转换器
struct "TypeConverter" {
	-- data type -> code type
	{ name = "fromvalue", type = Function, require = true },

	-- code type -> date type
	{ name = "tovalue",   type = Function, require = true },

	-- 作为第二个参数和值一并传入上面两个函数，一般是格式定义
	{ name = "format",    type = Any }
}

-- 为外键对应的主表申明的关联属性配置
struct "PrimaryLink" {
	{ name = "name",    type = String, require = true },
	{ name = "order",   type = String + QueryOrders },
}

-- 外键设置
struct "ForeignMap" {
	-- 外键和主表的主键的映射关系，外键作为键，主表的主键作为值，注意都是字段名
	{ name = "map",     type = Table, require = true },

	-- 主表的关联属性配置，如果只申明字符串，该字符串作为name，
	-- 那么查询时不指定Order
	{ name = "link",    type = String + PrimaryLink },
}

-- 字段配置结构体
struct "FieldSetting" {
	-- 字段名，默认采用属性名
	{ name = "name",        type = String },

	-- 字段的数据库类型，框架不使用，仅用于Code First设计模式下
	-- 更新数据库用
	{ name = "type",        type = String },

	-- 是否unique唯一
	{ name = "unique",      type = Boolean },

	-- 是否是自增字段，值由数据库自动生成
	{ name = "autoincr",    type = Boolean },

	-- 是否不能为空
	{ name = "notnull",     type = Boolean },

	-- 外键设定
	{ name = "foreign",     type = ForeignMap },

	-- 数据类型转换器，通常使用框架默认提供的即可
	{ name = "converter",   type = TypeConverter },

	-- 数据类型转换时的格式，通常使用框架默认提供的即可
	{ name = "format",      type = Any },
}
```

虽然配置项目很多，但很多时候，特别是DataBase First设计模式时，我们并不需要提供其中的大部分配置，类似外键虽然代码上方便使用，但如果限制外键使用时，也可以完全绕过不使用。类似unique, type, nonull也都并非必须提供，只是提供后，会带来更多检查和优化。所以很多时候

```lua
__DataField__()
property "name" { type = String }
```

就可以申明映射字段的属性了。外键可以参考最初的例子，另外不使用外键也是一个不错的设计选择。



### 数据的查询

在上面的例子中，我们已经定义了数据库上下文`UserDataContext`，它的里面定义了两个类`User`和`Login`，分别映射到数据库的`user`和`login`表。

我们可以通过使用数据库上下文对象的`Users`和`Logins`属性访问数据库表对应的数据集合。首先我们来看数据的查询(默认在上下文类的构造方法中提供了数据库连接）：

```lua
with(UserDataContext())(function(ctx)
	-- 通过table指定参数获取对象
	local user = ctx.Users:Query{ name = "ann", telno = "13412345678" }:First()

	-- 通过外键申明的主表属性拿去所有的登录时间记录
	for _, lg in user.LoginTimes:GetIterator() do
		print(lg.user.name, lg.login) -- 通过外键绑定的属性访问主表
	end

	-- table只能用于精确匹配，对于增删改都可以满足需求，但查询情况相对复杂，
	-- 为了简化，类似List的链式操作，框架为查询单独提供了一组链式处理，
	-- 其中Where处理可以直接使用SQL完成，框架无需提供更复杂的处理方式，
	-- 另外，因为查询结果是保存为对应实体类的对象，不支持JOIN这样的查询方式
	-- 这点也是为了性能考虑，如果需要JOIN处理，稍后介绍的QueryView会更加适合
	--
	-- SELECT * FROM user WHERE id > 12 ORDER BY name DESC, id OFFSET 30 LIMIT 10
	local users = ctx.Users:Where("id > %d", 12):OrderBy("name", true):OrderBy("id"):Offset(30):Limit(10):Query()
end)
```

`ctx.Users`会获取到一个数据集合，集合的元素类型是`UserDataContext.User`类，这个数据集合对象的类型是`System.Data.DataCollection[TestDBContext.Department]`，即利用`DataCollection`模板类根据传入的数据实体类，优化生成的。

生成的类提供数据集合操作的基本方法：

方法                |参数                                      |描述
:-------------------|:----------------------------------------|:----------------------------------
Query               |condition: Table, order:QueryOrders/nil  |根据排序和精确查询条件进行查询，取得的数据保存为数据实体类的对象，存入列表中返回
Query               |sql : String, ... : Any * 0              |直接使用SQL进行查询，取得的数据保存为数据实体类的对象，存入列表中返回
Lock                |condition: Table, order:QueryOrders/nil  |根据排序和精确查询条件进行查询并锁定数据，取得的数据保存为数据实体类的对象，存入列表中返回
QueryAll            |order:QueryOrders/nil                    |根据排序查询所有数据，取得的数据保存为数据实体类的对象，存入列表中返回
Add                 |data: Table                              |将指定的数据表封装成数据实体类的对象，加入数据集合，等待最后提交给数据库

数据集合的`Query`方法是基于数据库上下文的`Query`，将它返回的结果中，每行数据转换为对应的对象。当查询条件较为复杂时，使用SQL会更加方便，但为了尽可能减少SQL语句出现在代码中的可能，数据集合对象可以使用另一套链式处理：


队列方法             |参数                                     |描述
:-------------------|:----------------------------------------|:----------------------------------
Where               |condition: Table                         |为查询添加精确查询条件
Where               |condition: String, ... : Any * 0         |为查询条件自定义查询条件，condition中不需要出现`Where`，只需要加入查询条件即可，查询字段名可以是数据库字段名，也可以是对应的属性名，系统会自行替换
OrderBy             |name: String, desc: Boolean/nil          |为查询条件排序，可以被多次调用，这样可以指定多个排序条件
Limit               |limit: NaturalNumber                     |设置查询的限制数量
Offset              |offset: NaturalNumber                    |设置查询的位移数量


最终方法             |参数                                     |描述
:-------------------|:----------------------------------------|:----------------------------------
Lock                |                                         |锁定并返回结果集
Query               |                                         |返回查询结果集


下面是更多的用例：

```lua
-- SELECT xxx FROM item WHERE createdate = '2019-05-17' ORDER BY id DESC LIMIT 10 OFFSET 30
ctx.Items:Where{ createdate = Date.Now:AddDays(-1) }:OrderBy("id", true):Limit(10):Offset(30):Query()

-- SELECT xxx FROM item WHERE id in (1, 2, 3)
ctx.Items:Where("ID in (%s)", {1, 2, 3}):Query()  -- 转换属性ID为字段id
```

允许查询条件中使用属性名，而不是必须使用字段名，目的也是为了让查询条件更倾向于代码的逻辑，虽然我们必须沿用对应数据库的SQL语法，但通常这不会造成问题。

虽然查询相对复杂，但对于增删改来说，数据集合就相当方便了。


### 数据的创建

为了避免处理过程中失败，请使用`with`来操作数据库上下文对象：

```lua
-- 添加一个用户
function addUser(name, telno)
	local user

	with(UserDataContext())(function(ctx)
		with(ctx.Transaction)(function(trans)
			user        = ctx.Users:Add{
				name 	= name,
				telno 	= telno,
			}

			-- 先保存数据，这样user才能有id值
			ctx:SaveChanges()

			local login = ctx.Logins:Add{
				-- 也可以使用id = user.id
				user  	= user,
				login   = Date.Now,
			}

			-- 保存初次登录信息
			ctx:SaveChanges()
		end)
	end)

	return user
end
```

注意，外键对应的属性，可以将主表对象直接设置上去，这样外键会获取到主表的主键的值。也有利于后续关联操作。


### 数据的更新

更细数据，必须启动一个事务，然后`Lock`住数据后才能进行更新，这样数据实体对象的修改才会被系统追踪。

```lua
function UpdateUserName(telno, name)
	with(UserDataContext())(function(ctx)
		with(ctx.Transaction)(function(trans)
			local user = ctx.Users:Lock{ telno = telno }:First()

			if user the
				user.name = name
				ctx:SaveChanges()
			else
				-- 不做任何处理时，必须回滚，避免被提交
				trans:Rollback()
			end
		end)
	end)
end
```


### 数据的删除

```lua
function deleteUser(id)
	if not id then return end

	with(UserDataContext())(function(ctx)
		with(ctx.Transaction)(function(trans)
			local user = ctx.Users:Lock{ id = id }:First()

			if user the
				-- 这里只是标记自身需要被删除
				user:Delete()

				-- 提交删除操作
				ctx:SaveChanges()
			else
				trans:Rollback()
			end
		end)
	end)
end
```


### 数据类型的自动转换

通常从数据库查询的结果集，数据类型是普通的字符串和数字（如果数据库使用的库做了简单解析），但程序中，我们还会使用到Boolean, Date等类型，如果每次都依赖开发者自行转换，太过费时，而且容易出错。

数据实体对象使用属性读写字段值，而读写都是受框架控制的，所以，在这个读写过程中，系统可以干预处理，将业务数据类型和数据库字段类型进行相互转换。

在上面的`__DateField__`设置中，我们可以指定`converter`和`format`，这样，值就可以在业务数据类型和数据库字段类型之间自动转换。我们只需要关注业务数据类型，而不关心数据库字段的具体定义。

通常我们只需要针对`Date`和`Boolean`两种类型提供转换，而且一般转换是比较固定的，所以，框架针对这两个类型注册默认的转换器，无需在`__DataField__`中自行申明，如果有需要，也可以自己注册对应类型的默认转换器，稍后说明做法。

上面的`Login`表定义中，就使用到了`Date`类型，从例子中可以看到，我们可以直接使用`Date.Now`为它进行赋值，也可以使用更多日期操作:

```lua
-- 添加登录记录，允许使用mod修改秒数
function addLogin(id, mod)
	with(UserDataContext())(function(ctx)
		with(ctx.Transaction)(function(trans)
			local login = ctx.Logins:Add{
				id = id,
				login = Date.Now:AddSeconds(mod),
			}

			ctx:SaveChanges()
		end)
	end)
end
```

框架为日期类型注册的默认转换器，以及注册方式是：

```lua
__DataField__.Converter[Date] = {
    fromvalue       = Date.Parse,
    tovalue         = Date.ToString,
}
```

不过，这里没有提供默认的`format`，因为`Date`默认的转换格式是`%Y-%m-%d %X`，和`Mysql`的日期类型是一致的，如果需要使用不同的格式，也可以自行覆盖原设置，不需要为每个字段映射指定：

```lua
__DataField__.Converter[Date] = {
    fromvalue       = Date.Parse,
	tovalue         = Date.ToString,
	format          = "%Y-%m-%d",
}
```

通常也只有日期类型有格式设置的需求。如果只对某几个字段映射有单独设置格式的需求的话，可以申明为:

```lua
__DataField__{ notnull = true, format = "%Y-%m-%d" }
property "login"     { type = Date }
```

这样就覆盖了默认格式，但不会覆盖默认的转换器。

`Boolean`对应的转换器是:

```lua
__DataField__.Converter[Boolean] = {
	fromvalue       = function(value)
		return tonumber(value) == 1 or false
	end,
	tovalue         = function(object)
		return object and 1 or 0
	end,
}
```

所以，实际就是`1`对应`true`，`0`对应`false`。但使用时，仅仅需要类似  `if not entity.deleted then end` 做布尔判定即可，无需关心数据库的对应实现。


### DBNull

通常不同的数据库的访问库实现，会定义一些特殊的常量，用于表示空值的占位(`DBNull`)，在我们代码使用时，需要转换为nil使用，同时，我们修改数据实体对象的属性值时，如果给出nil值，对应到数据库的值也应该是`DBNull`，这样系统才能判定这里原本有值，现在需要设置为空。

`PLoop`提供的Web框架只是抽象实现，具体应用在不同平台的实现并不一致，所以，平台需要将自己使用的`DBNull`占位值注册到框架中，框架就能自动进行处理，例如对应[Openresty][]的`ngx.null`，框架需要提供以下的注册：

```lua
System.Data.AddNullValue(ngx.null)  -- for OpenResty
```

之后，我们可以用`ParseValue`过滤掉`ngx.null`，转换为nil，避免判定出错（特别if判定）：

```lua
value = System.Data.ParseValue(value)
```
另外，系统同时提供了一个属性值，当需要指定为`DBNull`值时使用:

```lua
entity.name = System.Data.DBNull
```

但是实际上，不管是`ParseValue`还是`DBNull`都并不需要在代码中直接使用，`__DataField__`封装属性的访问时，已经自行完成了处理，所以仅仅需要

```lua
entity.name = nil
```

即可，这样符合Lua的开发习惯，所以，通常`DBNull`只是底层使用，和应用开发者无关，这里着重提出，是如果自行实现这个抽象框架时，不要忘了注册类似`ngx.null`这样的`DBNull`占位变量。

对应于[Openresty][]，在[NgxLua][]中已经完成了全部实现（目前只覆盖了`Mysql`数据库，其他可以参考实现）


### 数据视图

综合上面的处理来说，**数据库上下文对象**提供了基础的查询功能，**数据集合**提供了将查询结果保存到**数据实体类**的对象的功能，通过这些对象，我们可以用业务逻辑类型去访问所有数据。

但**数据集合**只支持单表查询，并且通常更多的用于增删改的操作。如果仅仅是为了查询用，并且有多表查询的需求时，我们只能使用**数据库上下文对象**提供的基础查询，而结果需要自行转换数据。

另一方面来说，我们也需要尽可能的减少业务代码中SQL语句的出现，避免修改需要在多处文件中一一完成。这时我们可以使用**数据视图类**，它的功能和**数据实体类**接近，可以将读取到的数据，使用指定的类型来访问。

**数据视图类**仅关心数据的查询，所以，它的对象不会被框架追踪，修改也不会被提交到数据库，所以，它相对比较自由，可以处理多表查询的结果。

通常我们会为**数据视图类**绑定SQL语句，这样使用时，仅需要传入参数即可，这也确保了，它的结构和SQL定义在同一处，修改时，不用在各个应用代码中进行修改。下面看一个例子：

```lua
__DataView__[[select id, name, telno from user where id > %d order by id limit %d]]
class "UserPageView" (function(_ENV)
		__DataField__()
		property "id"    { type = NaturalNumber }

		__DataField__()
		property "name"  { type = String }

		__DataField__()
		property "telno" { type = String }
end)
```

和定义**数据实体类**接近，我们也同样可以使用`__DataField__`特性将属性映射到查询结果的字段，属性的类型会帮助我们转换结果值（仅当读取时转换，这也是一个优化处理）。

不同点在于，我们使用`__DataView__`申明**数据视图类**，并且绑定的是SQL语句，而不是数据库表。SQL语句中使用`%d`, `%s`等作为占位符，之后会被参数替代，进行查询。

上面的SQL语句用于分页处理，使用起来类似：

```lua
-- 查询前100个用户
local lst = ctx:QueryView(UserPageView, 0, 100)
```

使用处仅需要传入参数即可，返回的列表的元素是`UserPageView`的对象。另外，也可以不使用默认SQL，可以自行构建新的SQL语句，只需要保证查询字段结构一致即可：

```lua
local lst = ctx:QueryAsView(UserPageView, [[select id, name, telno from user where id < %d order by id desc limit %d]], 999, 100)
```

但通常不推荐这么做，将视图类和SQL语句绑定在一起更容易维护。

**数据实体类**和**数据视图类**都是可序列化的，在web框架中，可以直接将返回的列表作为JSON返回给客户端（列表自身就是可序列化的）。


## 特定数据库的对接

上述的**数据库上下文**，**数据集合**，**数据实体类**，**数据视图类**和**字段到属性的映射**是完整的抽象数据实体框架。它们完整的提供了整套数据模型和开发框架。但它们基于的数据库操作是抽象的，并不针对哪个数据库和使用平台。

为了对接到实际项目，我们需要提供对应数据库的实现，为此，框架申明了需要被实现的接口和细节（使用[NgxLua][]和Mysql数据库的可以跳过）：

```lua
-- 数据库连接状态
enum "ConnectionState" {
	Closed             	= 0,  -- 已关闭
	Open               	= 1,  -- 已打开
	Connecting      	= 2,  -- 正在连接
	Executing         	= 3,  -- 正在执行
	Fetching         	= 4,  -- 正在查询
}
		
-- 事务隔离
enum "TransactionIsolation" {
	REPEATABLE_READ         = 0,
	READ_UNCOMMITTED        = 1,
	READ_COMMITTED          = 2,
	SERIALIZABLE            = 3,
}

-- SQL构建器
interface "ISqlBuilder" (function(_ENV)
	--- 设置需要被选择的字段组
	-- @param fields   一个保存字段名的列表（普通table也可）或者一个包含字段名的字符串
	-- @return self    必须返回自身，以便完成链式操作，下同
	__Abstract__() function Select(self, fields) return self end

	--- 查询并锁定结果集
	-- @return self
	__Abstract__() function Lock(self) return self end

	--- 设置需要被更新的字段和值，生成更新语句
	-- @param map       一个映射字段和值的表
	-- @return self
	__Abstract__() function Update(self, map) return self end

	--- 设置删除标记，生成删除语句
	-- @return self
	__Abstract__() function Delete(self) return self end

	--- 设置插入时使用的字段和值，生成插入语句
	-- @param map       一个映射字段和值的表
	-- @return self
	__Abstract__() function Insert(self, map) return self end

	--- 设置对应的数据库表
	-- @param name      数据库表名
	-- @param alias     表的别名
	-- @return self
	__Abstract__() function From(self, name, alias) return self end

	--- 设置查询条件
	-- @param condition 查询条件，可以是精确查询用的table，或者是格式化字符串作为条件（不含where，仅判定语句）
	-- @return self
	__Abstract__() function Where(self, condition, ...) return self end

	--- 设置排序字段
	-- @param name      字段名
	-- @param desc      是否逆序
	-- @return self
	__Abstract__() function OrderBy(self, field, desc) return self end

	--- 生成SQL，这是上述操作执行完后，最后的处理
	-- @return sql      生成的SQL语句
	__Abstract__() function ToSql(self) end
end)

--- 数据库连接，管理连接和完成操作
interface "IDbConnection" (function(_ENV)
	extend "IAutoClose"

	-----------------------------------------------------------
	--                      抽象属性                          --
	-----------------------------------------------------------
	--- 连接状态
	__Abstract__() property "State"      { type = ConnectionState, default = ConnectionState.Closed }

	--- 实现ISqlBuilder的类，用于生成实际的查询语句，
	-- 注意并这个类并不会被IDbConnection的对象使用，而是被框架使用，
	-- 定义在这里是为了将同数据库的操作捆绑在一个类提供。
	__Abstract__() property "SqlBuilder" { type = -ISqlBuilder }

	-----------------------------------------------------------
	--                        抽象方法                        --
	-----------------------------------------------------------
	--- 返回一个新的数据库事务
	-- @param isolation   事务隔离级别
	__Abstract__() function NewTransaction(self, isolation) end

	--- 发送查询请求，返回结果集
	-- @param  sql   格式化Sql查询语句
	-- @param  ...   查询参数
	-- @return list  结果集列表
	__Abstract__() function Query(self, sql, ...) end

	--- 发送插入请求，并返回自增的id，如果存在
	-- @param  sql   格式化Sql插入语句
	-- @param  ...   插入参数
	-- @return id    自增id
	__Abstract__() function Insert(self, sql, ...) end

	--- 发送更新请求
	-- @param  sql   格式化Sql更新语句
	-- @param  ...   更新参数
	__Abstract__() function Update(self, sql, ...) end

	--- 发送删除请求
	-- @param  sql   格式化Sql删除语句
	-- @param  ...   删除参数
	__Abstract__() function Delete(self, sql, ...) end

	--- 执行任意请求，直接返回数据库处理结果
	-- @param  sql   格式化Sql语句
	-- @param  ...   参数
	-- @return ...   所有的数据库返回结果
	__Abstract__() function Execute(self, sql, ...) end
end)

--- 数据库事务接口，用于执行一组操作，可以回滚处理
interface "IDbTransaction" (function(_ENV)
	extend "IAutoClose"  -- 虽然扩展了这个接口，但不需要自行实现Open/Close方法，这个接口已经实现了

	-----------------------------------------------------------
	--                        抽象属性                        --
	-----------------------------------------------------------
	--- 事务的数据库链接，通常在使用IDbConnection的NewTransaction中设置即可
	__Abstract__() property "Connection"        { type = IDbConnection }

	--- 事务的隔离等级，同样应该在NewTransaction中设置
	__Abstract__() property "Isolation"         { type = TransactionIsolation, default = TransactionIsolation.REPEATABLE_READ }

	-----------------------------------------------------------
	--                        抽象方法                        --
	-----------------------------------------------------------
	--- 开始事务
	__Abstract__() function Begin(self) end

	--- 确认事务
	__Abstract__() function Commit(self) end

	--- 回滚事务
	__Abstract__() function Rollback(self) end
end)
```

注意，上面涉及的字段-数据表，处理的数据都已经转换为字段类型对应的数据格式，和**数据实体类**的属性类型无关，这一块都是更底层的处理，不涉及上面的类。

下面看一个简单的实现：

```lua
require "PLoop.System.Data"

PLoop(function(_ENV)
	import "System.Data"

	class "MySQLConnection" {} -- 先申明，稍后具体实现

	-- 事务实现
	__Sealed__() class "MySQLTransaction" (function(_ENV)
		extend "IDbTransaction"

		-----------------------------------------------------------
		--                          方法                          --
		-----------------------------------------------------------
		function Begin(self)
			self.Connection:Execute("TRANSACTION BEGIN")
		end
		
		function Commit(self)
			self.Connection:Execute("TRANSACTION COMMIT")
		end

		function Rollback(self)
			self.Connection:Execute("TRANSACTION ROLLBACK")
		end

		-----------------------------------------------------------
		--                         构造体                         --
		-----------------------------------------------------------
		__Arguments__{ MySQLConnection, TransactionIsolation/TransactionIsolation.REPEATABLE_READ }
		function __ctor(self, conn, isolation)
			self.Connection = conn
			self.Isolation  = isolation
		end
	end)

	-- Sql构建器
	__Sealed__() class "MySQLBuilder" (function(_ENV)
		extend "ISqlBuilder"

		export {
			SQLTYPE_SELECT      = 1,
			SQLTYPE_UPDATE      = 2,
			SQLTYPE_DELETE      = 3,
			SQLTYPE_INSERT      = 4,

			FIELD_SQLTYPE       = 1,
			FIELD_SELECT        = 2,
			FIELD_UPDATE        = 3,
			FIELD_INSERT        = 4,
			FIELD_FROM          = 5,
			FIELD_WHERE         = 6,
			FIELD_ORDERBY       = 7,

			quote_sql_str       = function(str) return ("%q"):format(str) end,
			type                = type,
			tblconcat           = table.concat,
			tostring            = tostring,
			pairs               = pairs,

			DBNull              = System.Data.DBNull,
		}

		local function escape(val)
			-- 对DBNull的特别转换
			if val == DBNull then return "NULL" end

			local vtype         = type(val)

			if vtype == "boolean" then
				return val and "1" or "0"
			elseif vtype == "string" then
				return quote_sql_str(val)
			else
				return tostring(val)
			end
		end

		-----------------------------------------------------------
		--                          方法                          --
		-----------------------------------------------------------
		function Select(self, fields)
			self[FIELD_SQLTYPE] = SQLTYPE_SELECT

			if type(fields) == "table" then
				fields          = tblconcat(fields, ",")
			else
				fields          = tostring(fields)
			end

			self[FIELD_SELECT]  = fields ~= "" and fields or nil

			return self
		end

		function Insert(self, map)
			if type(map) == "table" then
				self[FIELD_SQLTYPE] = SQLTYPE_INSERT

				local fields    = {}
				local values    = {}
				local index     = 1

				for fld, val in pairs(map) do
					fields[index] = fld
					values[index] = escape(val)
					index       = index + 1
				end

				fields          = tblconcat(fields, ",")
				values          = tblconcat(values, ",")

				if fields ~= "" then
					self[FIELD_SELECT] = fields
					self[FIELD_INSERT] = values
				end
			end

			return self
		end

		function Update(self, map)
			self[FIELD_SQLTYPE] = SQLTYPE_UPDATE

			if type(map) == "table" then
				local temp      = {}
				local index     = 1
				local first     = true

				for fld, val in pairs(map) do
					if not first then
						temp[index] = ","
						index   = index + 1
					end
					first       = false

					temp[index] = fld
					index       = index + 1

					temp[index] = "="
					index       = index + 1

					temp[index] = escape(val)
					index       = index + 1
				end

				map             = tblconcat(temp, "")
			else
				map             = tostring(map)
			end

			self[FIELD_UPDATE]  = map ~= "" and map or nil

			return self
		end

		function Delete(self)
			self[FIELD_SQLTYPE] = SQLTYPE_DELETE

			return self
		end

	   function From(self, name)
			self[FIELD_FROM]    = name
			return self
		end

		function Where(self, condition)
			if type(condition) == "table" then
				local temp      = {}
				local index     = 1
				local first     = true

				for fld, val in pairs(condition) do
					if not first then
						temp[index] = " AND "
						index   = index + 1
					end
					first       = false

					temp[index] = fld
					index       = index + 1

					temp[index] = "="
					index       = index + 1

					temp[index] = escape(val)
					index       = index + 1
				end

				condition       = tblconcat(temp, "")
			else
				condition       = tostring(condition)
			end

			self[FIELD_WHERE]   = condition ~= "" and condition or nil

			return self
		end

		function OrderBy(self, field, desc)
			if desc then field  = field .. " DESC" end

			if self[FIELD_ORDERBY] then
				self[FIELD_ORDERBY] = self[FIELD_ORDERBY] .. "," .. field
			else
				self[FIELD_ORDERBY] = field
			end

			return self
		end

		function ToSql(self)
			local temp          = {}

			local sqltype       = self[FIELD_SQLTYPE]

			if not sqltype then return end

			if sqltype == SQLTYPE_SELECT then
				temp[1]         = "SELECT"
				temp[2]         = self[FIELD_SELECT] or "*"
				temp[3]         = "FROM"

				if not self[FIELD_FROM] then return end
				temp[4]         = self[FIELD_FROM]

				if self[FIELD_WHERE] then
					temp[5]     = "WHERE"
					temp[6]     = self[FIELD_WHERE]
				else
					temp[5]     = ""
					temp[6]     = ""
				end

				if self[FIELD_ORDERBY] then
					temp[7]     = "ORDER BY"
					temp[8]     = self[FIELD_ORDERBY]
				else
					temp[7]     = ""
					temp[8]     = ""
				end
			elseif sqltype == SQLTYPE_UPDATE then
				temp[1]         = "UPDATE"

				if not self[FIELD_FROM] then return end
				temp[2]         = self[FIELD_FROM]
				temp[3]         = "SET"

				if not self[FIELD_UPDATE] then return end
				temp[4]         = self[FIELD_UPDATE]

				if self[FIELD_WHERE] then
					temp[5]     = "WHERE"
					temp[6]     = self[FIELD_WHERE]
				else
					temp[5]     = ""
					temp[6]     = ""
				end
			elseif sqltype == SQLTYPE_DELETE then
				temp[1]         = "DELETE FROM"

				if not self[FIELD_FROM] then return end
				temp[2]         = self[FIELD_FROM]

				if self[FIELD_WHERE] then
					temp[3]     = "WHERE"
					temp[4]     = self[FIELD_WHERE]
				else
					return
				end
			elseif sqltype == SQLTYPE_INSERT then
				temp[1]         = "INSERT INTO"

				if not self[FIELD_FROM] then return end
				temp[2]         = self[FIELD_FROM]

				if not self[FIELD_SELECT] then return end

				temp[3]         = "("
				temp[4]         = self[FIELD_SELECT]
				temp[5]         = ") VALUES ("

				if not self[FIELD_INSERT] then return end

				temp[6]         = self[FIELD_INSERT]
				temp[7]         = ")"
			end

			return tblconcat(temp, " ")
		end

		-----------------------------------------------------------
		--                      constructor                      --
		-----------------------------------------------------------
		function __new(self)
			return {
				[FIELD_SQLTYPE] = false,
				[FIELD_SELECT]  = false,
				[FIELD_UPDATE]  = false,
				[FIELD_INSERT]  = false,
				[FIELD_FROM]    = false,
				[FIELD_WHERE]   = false,
				[FIELD_ORDERBY] = false,
			}, true
		end
	end)

	-- 数据库连接
	__Sealed__() class "MySQLConnection" (function(_ENV)
		extend "IDbConnection"

		property "SqlBuilder" { set = false, default = MySQLBuilder }

		-----------------------------------------------------------
		--                         方法                          --
		-----------------------------------------------------------
		__Arguments__{ TransactionIsolation/TransactionIsolation.REPEATABLE_READ }
		function NewTransaction(self, isolation)
			return MySQLTransaction(self, isolation)
		end

		function Close(self)
			print("[Connection][Close]")
		end

		function Open(self)
			print("[Connection][Open]")
		end

		function Query(self, sql)
			print("[SQL][Query]", sql)
		end

		function Insert(self, sql)
			print("[SQL][Insert]", sql)
		end

		function Update(self, sql)
			print("[SQL][Update]", sql)
		end

		function Delete(self, sql)
			print("[SQL][Delete]", sql)
		end

		function Execute(self, sql)
			print("[SQL][Execute]", sql)
		end
	end)

	-- 测试
	__DataContext__()
	class "UserDataContext" (function(_ENV)
		function __ctor(self)
			self.Connection = MySQLConnection()
		end

		__DataTable__ {
			name         = "user",

			indexes      = {
				{ fields = { "id" },   primary = true },
				{ fields = { "name" },  unique = true },
				{ fields = { "telno" },  unique = true },
			}
		}
		class "User" (function(_ENV)
			__DataField__{ autoincr = true }
			property "id"           { type = NaturalNumber }

			__DataField__{ notnull = true }
			property "name"         { type = String }

			__DataField__{ notnull = true }
			property "telno"        { type = String }
		end)
	end)

	-- [Connection][Open]
	with(UserDataContext())(function(ctx)
		-- [SQL][Query] SELECT id, name, telno FROM user WHERE id=1
		local e = ctx.Users:Query{ id = 1 }:First()

		-- [SQL][Execute]   TRANSACTION BEGIN
		with(ctx.Transaction)(function(tran)
			e = ctx.Users:Add{ name = "Ann" }

			-- [SQL][Insert]    INSERT INTO user ( name ) VALUES ( "Ann" )
			ctx:SaveChanges()
		end)
		-- [SQL][Execute]  TRANSACTION COMMIT
	end)
	-- [Connection][Close]
end)
```


## 缓存数据类库

数据库虽然便利，但速度上在很多场景，特别是高并发的Web服务场景中，会成为整套程序的瓶颈，为了解决这个问题，我们通常需要使用类似redis, memcache这类基于内存的缓存数据库，它通常仅保留key-value键值对，并且可以通过指定超时时间的方式来管理键值对的生存周期。

缓存数据库相对复杂一些，关系型数据库不管如何设计，使用设计上差距不大，但缓存数据库的实现方式和数据保存方式都相对比较自由，因此缓存框架仅为系统需要使用的功能申明了抽象方法，具体实现依赖于指定的缓存数据库，实现可以参考[NgxLua][]中定义的`RedisProvider`。

### System.Data.ICache

`ICache`接口为缓存类申明了必须被实现的方法：

```lua
interface "System.Data.ICache" (function(_ENV)
	extend "System.IAutoClose"

	-----------------------------------------------------------
	--                        抽象方法                        --
	-----------------------------------------------------------
	--- 尝试向缓存数据库写入键值对，如果键已存在，不做任何操作，如果设置成功，需要返回true
	-- @param  key         键
	-- @param  value       值
	-- @param  expiretime  过期时间，需要能处理剩余秒数或特定Date
	-- @return success
	__Abstract__() function TrySet(self, key, value, expiretime) end

	--- 向缓存数据库写入键值对
	-- @param  key         键
	-- @param  value       值
	-- @param  expiretime  过期时间，需要能处理剩余秒数或特定Date
	__Abstract__() function Set(self, key, value, expiretime) end

	--- 为特定键刷新过期时间
	-- @param  key         键
	-- @param  expiretime  过期时间，需要能处理剩余秒数或特定Date
	__Abstract__() function SetExpireTime(self, key, expiretime) end

	--- 获取指定键的值
	-- @param  key         键
	-- @return value       对应的值
	__Abstract__() function Get(self, key) end

	--- 键是否存在
	-- @param  key         键
	-- @return existed     是否存在于缓存数据库
	__Abstract__() function Exist(self, key) end

	--- 删除指定的键
	-- @param  key         键
	__Abstract__() function Delete(self, key) end
end)
```

传入的值可能是可序列化对象，因为系统无法了解缓存如何实现（我们甚至可以用Lua的table作为缓存），所以，序列化/反序列化操作需要由缓存类自行处理。

在[NgxLua][]中可以找到两个缓存类的实现: `NgxLua.Redis`对应Redis缓存数据库，`NgxLua.ShareDict`对应[Openresty][]提供的共享表。

下面是它的使用例子：

```lua
require "NgxLua"

PLoop(function(_ENV)
	-- 打开服务器: 127.0.0.1:6379
	with(NgxLua.Redis{ host = "127.0.0.1", port = 6379 })(function(redis)
		-- 添加一个用户记录，保留10分钟，注意，Redis已经实现了序列化和反序列化，所以，可以直接保存对象和table
		redis:Set("user_100", { id = 100, name = "Ann" }, Date.Now:AddMinutes(10))
	end)
end)
```


### System.Data.DataEntityCache

在实际系统中，我们读取数据实体对象时，会将从数据库得到的对象保存到缓存中，这样下一次获取时，直接从缓存获取即可，这比从数据库读取要节省大量的时间。为此，通常得到一个ID，去查询对象时，我们需要先检查缓存，不存在再从数据库获取，获取到后，将它保存在缓存中以备下次使用。

这个过程实际非常通用，为了简化处理，系统提供了`DataEntityCache`这个模板类型，给定主键后，它会优先查询缓存，再查询数据库，因为统一封装，它并不一定是最优选择，但也是比较方便的一个方案。

首先看一个使用上的例子：

```lua
class "UserCache" (function(_ENV)
	-- 模板的第一个参数是数据实体类
	-- 通常在UserDataContext的构造体中申明数据库连接
	-- 申明了User类后，UserCache会找它所在的上下文类
	-- 然后使用该类操作数据库，所以无需自行申明数据库连接
	--
	-- 第二个参数是缓存类，同样，通常可以在构造体中实现缓存数据库连接
	-- 而Redis的默认连接是127.0.0.1:6379，通常是本地Redis服务，所以这里直接使用Redis
	-- 而不是继承它实现自己连接的类。
	-- 第二个参数可以省略，但就需要在这个类的构造体方法中，自行给Cache属性赋值
	inherit (System.Data.DataEntityCache[{UserDataContext.User, NgxLua.Redis }])

	-- 唯一需要定义的属性，定义了超时时间，这里设置为3600秒
	property "Timeout" { type = NaturalNumber, default = 3600 }
end)

function getUser(id)
	return with(UserCache())(function(cache)
		-- 读取和设置都需要通过主键完成，支持多主键
		-- 这也是为什么要求定义数据实体类时，需要把主键申明好
		-- 如果多主键，按照主键的申明顺序使用
		return cache:GetEntity(id)
	end)
end
```

下面是具体的定义（虽然是抽象属性，但并不是需要被实现）：

抽象属性                   |类型                             |描述
:-------------------------|:--------------------------------|:----------------------------
DataContext               |IDataContext                     |访问和设置数据库上下文对象，默认从指定的数据实体类获取它所在的上下文类，然后直接构建对象（无传入参数）
Cache                     |ICache                           |访问和设置缓存操作对象，默认从用传入的缓存类创建，直接构建对象（无传入参数）
Timeout                   |NaturalNumber                    |访问和设置超时时间，默认nil，不会超时
------------------------------------------------------------------------------------------

方法                      |参数                              |描述
:-------------------------|:--------------------------------|:----------------------------
GetEntity                 |... : Any * 0                    |传入所有主键的值，获取数据实体对象
GetEntity                 |query: Table                     |传入含所有主键及对应值的表，获取数据实体对象
SaveEntity                |entity                           |将指定的数据实体按照主键保存到缓存
DeleteEntity              |entity                           |从缓存中删除指定的主键

上述的方法都会根据数据实体类定义的属性类型，进行参数校验，这也是模板类的一个使用特征，可以针对传入的类进行特定的优化。

注意，`SaveEntity`和`DeleteEntity`仅针对缓存数据库进行操作，不会提交到数据库。仅仅是为了刷新缓存用。

```lua
function updateUser(id, name, telno)
	if not id then return end

	with(UserDataContext())(function(ctx)
		with(ctx.Transaction)(function(trans)
			local user = ctx.Users:Lock{ id = id }:First()

			if user then
				user.name = name
				user.telno = telno

				ctx:SaveChanges()

				with(UserCache())(function(cache)
					cache:SaveEntity(user)
				end)
			else
				trans:Rollback()
			end
		end)
	end)
end
```

请注意保持缓存和数据库数据一致，这点数据库上下文不会提供自动处理。


[NgxLua]: https://github.com/kurapica/NgxLua/ "The implementation for Openresty"
[Openresty]: https://github.com/openresty/lua-nginx-module "Embed the Power of Lua into NGINX HTTP servers"