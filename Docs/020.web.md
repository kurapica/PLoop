# System.Web

**System.Web** is a web framework designed to be an abstract layer for web development, it'd provide interfaces and features that not depends on the web server.

The System only support UTF-8 for now.

This is an abstract framework so can't be used in any web server directly, You can find runnable example [PLoop.Browser][], it used an implementation [NgxLua][] which is designed for the [Openresty][].


## Table of Contents

* [System.Web.Application](#systemwebapplication)
	* [`System.Web.__Json__`](#systemweb__json__)
	* [`System.Web.__Text__`](#systemweb__text__)
	* [`System.Web.__Redirect__`](#systemweb__redirect__)
	* [`System.Web.__View__`](#systemweb__view__)
* [System.Web Constant](#systemweb-constant)
* [Encode & Decode](#encode--decode)
* [System.Web.HttpContext](#systemwebhttpcontext)
* [System.Web.HttpRequest](#systemwebhttprequest)
* [System.Web.HttpResponse](#systemwebhttpresponse)
* [System.Web.HttpCookie & System.Web.HttpCookies](#systemwebhttpcookie--systemwebhttpcookies)
* [System.Web.Session](#systemwebsession)
	* [System.Web.ISessionIDManager](#systemwebisessionidmanager)
	* [System.Web.ISessionStorageProvider](#systemwebisessionstorageprovider)
* [System.Web.Route](#systemwebroute)
* [Page Rendering](#page-rendering)
	* [Lua Server Page (.lsp)](#lua-server-page-lsp)
	* [Master Page (.master)](#master-page-master)
	* [Super web part](#super-web-part)
	* [Mix HTML with lua](#mix-html-with-lua)
		* [Block](#block)
		* [Inline](#inline)
		* [Full-line](#full-line)
		* [Mixed Method](#mixed-method)
	* [Helper Page (.helper)](#helper-page-helper)
	* [Embed Page (.embed)](#embed-page-embed)
	* [Inner Request Page](#inner-request-page)
	* [Lua Code file (.lua)](#lua-code-file-lua)
* [System.Web.MVC](#systemwebmvc)
	* [System.Web.Controller](#systemwebcontroller)
* [Form Validation](#form-validation)
* [User Authentication](#user-authentication)
	* [Login validation](#login-validation)
	* [Authority Checking](#authority-checking)
* [Context Handler](#context-handler)
* [Error Handler](#error-handler)
* [Relative Path & Absolute Path](#relative-path--absolute-path)
* [System.Web.Config](#systemwebconfig)
* [Configuration For Templates](#configuration-for-templates)
* [Custom Render Engine](#custom-render-engine)


## System.Web.Application

An **Application** is a standalone web service, a server like *nginx* can host several applications. The application will have its own configurations, routers, controllers and etc.

Here is a simple web application:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"  -- The System.Web will load the PLoop

app = Application "TestWebApp" (function(_ENV)
	__Route__("/jsonhandler", HttpMethod.GET)
	__Json__() function JsonHandler(context)
		return {
			Data = {
				{ Name = "Ann", Age =  12},
				{ Name = "King", Age =  32},
				{ Name = "July", Age =  22},
				{ Name = "Sam", Age =  30},
			}
		}
	end
end)
```

Before loading the **PLoop**, we must set the **MULTI_OS_THREAD** to true, since web service like the [Openresty][] is a multi-os thread platform.

The **Application** is inheirted from the **System.Module**, so normally it works like the module system.

In the app, we have a *JsonHandler* function who has two attribute:

* `__Route__("/jsonhandler", HttpMethod.GET)` register the function as the handler for route `/jsonhandler` when the http method is "GET"
* `__Json__` means the return value of the function will be serialized to JSON format and send to the response.

Now we can simulate the process of the http request and get a result from the web app:

```lua
-- Copy the previous example code here

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.CombinePath(IO.Path.GetCurrentPath(), "root")
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

-- {"Data":[{"Name":"Ann","Age":12},{"Name":"King","Age":32},{"Name":"July","Age":22},{"Name":"Sam","Age":30}]}
main("/jsonhandler")
```

In the main function, we create the **HttpContext** of the web app and then we create the **HttpRequest** and **HttpResponse** of the context.

After those objects created, we can call the **Process** method of the context, the context will check the web app's router system to find a match handler to url, and then use the handler to process the request and send the result to the response.

In a real project, the request, response is generated by the system, you don't need to manually do it.

For those handlers defined in the application, they are the static route handlers.


### `System.Web.__Json__`

As we can see the `__Json__` attribute will wrap the function and use it as the route handler, the return value of the function should be serialized to JSON format data.

The funciton will receive the http context object, so we can get the query string or form from the request:

```lua
__Route__("/jsonhandler", HttpMethod.GET)
__Json__() function JsonHandler(context)
	return {
		User = { Name = context.Request.QueryString.name }
	}
end

-- {"User":{"Name":"ann"}}
main("/jsonhandler", {name = "ann"})
```

The other codes are skipped, you can test it by your own.


### `System.Web.__Text__`

The `__Text__` attribute is used to generate the text as response, it can only return a text or be used as an iterator to generate the texts:

```lua
__Route__("/text", HttpMethod.GET)
__Text__() function TextHandler(context)
	return "Hello, this is single text test"
end

__Route__("/multitext", HttpMethod.GET)
__Text__(true) __Iterator__()
function MultiText(context)
	coroutine.yield("This is part of the result\n")
	coroutine.yield("This is another part of the result\n")
end

-- Hello, this is single text test
main("/text")

-- This is part of the result
-- This is another part of the result
main("/multitext")
```

The `__Text__(true)` means the function is async, should be used as an iterator.


### `System.Web.__Redirect__`

The `__Redirect__` attribute is used to redirect the client to a new url, the function should return the new url.

```lua
__Route__("/redirect")
__Redirect__() function TextHandler(context)
	return context.Request.QueryString.path or "/404"
end
```


### `System.Web.__View__`

The `__View__` attribute is used to bind a view template or template file path to the target function, so the return value of the function will be used to generate the output response:

```lua
__Route__("/index")
__View__ "index.view" [[
	<html>
		<head>
			<title>@self.title</title>
		</head>
		<body>
			<p>@self.welcome</p>
		</body>
	</html>
]]
function index(context)
	local name = context.Request.QueryString.name

	return { title = "Hi " .. name, welcome = "Welcome here, " .. name }
end


-- <html>
--    <head>
--        <title>Hi Ann</title>
--    </head>
--    <body>
--        <p>Welcome here, Ann</p>
--    </body>
-- </html>
main("/index", { name = "Ann" })
```

The `index.view` has two usage, the `index` will be used to generate as the view class name, and the `.view` will notify the system to use the registered **ResourceLoader** to load the text to a view class. Then the view class would be used to generate the output.

For the snippet `@self.title` in the template, the self is a view class's object, it'd use the return value from the function as the object's init-table.

If we don't specific the view template in the `__View__` attribtue, the function should return the view file path and the data like :

```lua
__Route__("/index")
__View__() function index(context)
	local ver = tonumber(context.Request.QueryString.ver)

	if ver == 1 then
		return "/view/index_v1.view", { data = context.Request.QueryString }
	else
		return "/view/index_last.view", { data = context.Request.QueryString }
	end
end
```

Normally the view is used in the MVC framework, we'll see more details about the template system at later.


## System.Web Constant

Here is the list of **System.Web** enums.

```lua
__Flags__() __Sealed__() __Default__"GET"
enum "HttpMethod" {
	ALL                 = 0,
	"OPTIONS",
	"GET",
	"HEAD",
	"POST",
	"PUT",
	"DELETE",
	"TRACE",
	"CONNECT",
}

--- the http status
__Sealed__() __Default__ "OK"
enum "HTTP_STATUS" {
	CONTINUE            = 100,  --The request can be continued.
	SWITCH_PROTOCOLS    = 101,  --The server has switched protocols in an upgrade header.
	OK                  = 200,  --The request completed successfully.
	CREATED             = 201,  --The request has been fulfilled and resulted in the creation of a new resource.
	ACCEPTED            = 202,  --The request has been accepted for processing, but the processing has not been completed.
	PARTIAL             = 203,  --The returned meta information in the entity-header is not the definitive set available from the originating server.
	NO_CONTENT          = 204,  --The server has fulfilled the request, but there is no new information to send back.
	RESET_CONTENT       = 205,  --The request has been completed, and the client program should reset the document view that caused the request to be sent to allow the user to easily initiate another input action.
	PARTIAL_CONTENT     = 206,  --The server has fulfilled the partial GET request for the resource.
	WEBDAV_MULTI_STATUS = 207,  --This indicates multiple status codes for a single response. The response body contains Extensible Markup Language (XML) that describes the status codes. For more information, see HTTP Extensions for Distributed Authoring.
	AMBIGUOUS           = 300,  --The requested resource is available at one or more locations.
	MOVED               = 301,  --The requested resource has been assigned to a new permanent Uniform Resource Identifier (URI), and any future references to this resource should be done using one of the returned URIs.
	REDIRECT            = 302,  --The requested resource resides temporarily under a different URI.
	REDIRECT_METHOD     = 303,  --The response to the request can be found under a different URI and should be retrieved using a GET HTTP verb on that resource.
	NOT_MODIFIED        = 304,  --The requested resource has not been modified.
	USE_PROXY           = 305,  --The requested resource must be accessed through the proxy given by the location field.
	REDIRECT_KEEP_VERB  = 307,  --The redirected request keeps the same HTTP verb. HTTP/1.1 behavior.
	BAD_REQUEST         = 400,  --The request could not be processed by the server due to invalid syntax.
	DENIED              = 401,  --The requested resource requires user authentication.
	PAYMENT_REQ         = 402,  --Not implemented in the HTTP protocol.
	FORBIDDEN           = 403,  --The server understood the request, but cannot fulfill it.
	NOT_FOUND           = 404,  --The server has not found anything that matches the requested URI.
	BAD_METHOD          = 405,  --The HTTP verb used is not allowed.
	NONE_ACCEPTABLE     = 406,  --No responses acceptable to the client were found.
	PROXY_AUTH_REQ      = 407,  --Proxy authentication required.
	REQUEST_TIMEOUT     = 408,  --The server timed out waiting for the request.
	CONFLICT            = 409,  --The request could not be completed due to a conflict with the current state of the resource. The user should resubmit with more information.
	GONE                = 410,  --The requested resource is no longer available at the server, and no forwarding address is known.
	LENGTH_REQUIRED     = 411,  --The server cannot accept the request without a defined content length.
	PRECOND_FAILED      = 412,  --The precondition given in one or more of the request header fields evaluated to false when it was tested on the server.
	REQUEST_TOO_LARGE   = 413,  --The server cannot process the request because the request entity is larger than the server is able to process.
	URI_TOO_LONG        = 414,  --The server cannot service the request because the request URI is longer than the server can interpret.
	UNSUPPORTED_MEDIA   = 415,  --The server cannot service the request because the entity of the request is in a format not supported by the requested resource for the requested method.
	RETRY_WITH          = 449,  --The request should be retried after doing the appropriate action.
	SERVER_ERROR        = 500,  --The server encountered an unexpected condition that prevented it from fulfilling the request.
	NOT_SUPPORTED       = 501,  --The server does not support the functionality required to fulfill the request.
	BAD_GATEWAY         = 502,  --The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.
	SERVICE_UNAVAIL     = 503,  --The service is temporarily overloaded.
	GATEWAY_TIMEOUT     = 504,  --The request was timed out waiting for a gateway.
	VERSION_NOT_SUP     = 505,  --The server does not support the HTTP protocol version that was used in the request message.
}
```


## Encode & Decode

There are four useful encode/decode method defined in the **System.Web**:

Method             |Arguments                                                            |Description
:------------------|:--------------------------------------------------------------------|:------------------------------
HtmlEncode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |Encodes a string to be displayed in a browser
HtmlDecode         |text:String, encode:System.Text.Encoding/System.Text.UTF8Encoding    |Decodes a string that has been encoded to eliminate invalid HTML characters
UrlEncode          |text:String                                                          |Encodes a URL string
UrlDecode          |text:String                                                          |Converts a URL string into a decoded string

```lua
require "PLoop.System.Web"

PLoop(function(_ENV)
	local str = HtmlEncode("<test>")
	print(str)               -- &lt;test&gt;
	print(HtmlDecode(str))   -- <test>

	str       = UrlEncode("/test?x=123")
	print(str)               -- %2Ftest%3Fx%3D123
	print(UrlDecode(str))    -- /test?x=123
end)
```


## System.Web.HttpContext

When a http request reached the system, a http context object must be created to process the request. A context object will provide several features:

Abstract Property           |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Request                     |HttpRequest                       |The object contains all request informations
Response                    |HttpResponse                      |The object used to generate the response
SessionType                 |- HttpSession                     |The session type that would be used to generate the session object

Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Application                 |Application                       |The web application of the context, it contains all features like routers, controllers and etc, it must be assgined before process the request
ProcessPhase                |IHttpContextHandler.ProcessPhase  |The current process phase, explain later
Session                     |HttpSession                       |Gets the session object from the current context
IsInnerRequest              |Boolean                           |Whether this is an inner request

Method                      |Arguments                                                   |Description
:---------------------------|:-----------------------------------------------------------|:-------------------------
Process                     |                                                            |Process the http request
ProcessInnerRequest         |url: String, params: Table/nil, HttpMethod/HttpMethod.GET   |Process an inner request, like retrieve json result from other url as data

although the class is not abstract, but features like the abstract properties must be implemented by the real http context class must be created based on the platform, you can find one implementation in the [NgxLua][].


## System.Web.HttpRequest

The http request contains all informations from the client, although the class is not abstract, but but features like the abstract properties must be implemented by the real http request class must be created based on the platform, you can find one implementation in the [NgxLua][].

Abstract Property           |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
ContentLength               |                                  |Specifies the length, in bytes, of content sent by the client
ContentType                 |                                  |Gets the MIME content type of the incoming request
Cookies                     |                                  |Gets a collection of cookies sent by the client
Form                        |                                  |Gets a collection of form variables
HttpMethod                  |                                  |Gets the HTTP data transfer method (such as GET, POST, or HEAD) used by the client
IsSecureConnection          |                                  |Gets a value indicating whether the HTTP connection uses secure sockets (that is, HTTPS)
QueryString                 |                                  |Gets the collection of HTTP query string variables
RawUrl                      |                                  |Gets the raw URL of the current request
Root                        |                                  |Get the root path of the query document
Url                         |                                  |Gets information about the URL of the current request

Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |The http context of the request
Handled                     |Boolean                           |Whether the request is handled


## System.Web.HttpResponse

The http response will send the response to the client, although the class is not abstract, but features like the abstract properties must be implemented by the real http response class must be created based on the platform, you can find one implementation in the [NgxLua][].

Abstract Property           |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
ContentType                 |                                  |Gets or sets the HTTP MIME type of the output stream.
RedirectLocation            |                                  |Gets or sets the value of the Http Location header.
RequestRedirected           |                                  |Whether the request is been redirected.
Write                       |                                  |Gets or sets the response write function or callable writer.
StatusCode                  |                                  |Gets or sets the HTTP status code of the output returned to the client.
Cookies                     |System.Web.HttpCookies            |Gets a collection of cookies sent to the client.


Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |The http context of the response


Abstract Method             |Arguments                         |Description
:---------------------------|:---------------------------------|:-------------------------
SendHeaders                 |                                  |Send the response headers
Close                       |                                  |Finish the response, used to close resources such like output wirter
ServerRedirect              |                                  |Server redirect the client to a new URL


Method                      |Arguments                                                                |Description
:---------------------------|:------------------------------------------------------------------------|:-------------------------
Redirect                    |url: String, code: HTTP_STATUS/HTTP_STATUS.REDIRECT, raw: Boolean/false  |Redirects the client to a new URL, the application may be used for the secondary domain, so it'll have a root path like '/mydomain/', if not raw, the url will be converted to '/mydomain/' + url


## System.Web.HttpCookie & System.Web.HttpCookies

The request's **Cookies** should be a name-value collections (just a table) that contains the cookie pairs send by the client's browser. So it can be used like :

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function test(context)
	return {
		User = { Name = context.Request.Cookies["name"] }
	}
end
```

Save cookies to the response is a little different, The **HttpResponse.Cookies** is a **System.Web.HttpCookies** which is a collection of **System.Web.HttpCookie**. Using a cookie name in it would create or get the created cookie, so you can use it like :

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function writecookie(context)
	context.Response.Cookies["ID"].Value = "TestUser1234"
	return {}
end
```

The **HttpCookie** contains several properties could be set:

Property                    |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Domain                      |String                            |Gets or sets the domain to associate the cookie with.
Expires                     |Date                              |Gets or sets the expiration date and time for the cookie.
MaxAge                      |Number                            |Gets or sets the max age for the cookie.
HasKeys                     |Boolean                           |Gets a value indicating whether a cookie has subkeys.
HttpOnly                    |Boolean                           |Gets or sets a value that specifies whether a cookie is accessible by client-side script.
Name                        |String                            |Gets or sets the name of a cookie.
Path                        |String                            |Gets or sets the virtual path to transmit with the current cookie.
Secure                      |Boolean                           |Gets or sets a value indicating whether to transmit the cookie using Secure Sockets Layer (SSL)--that is, over HTTPS only.
Value                       |String                            |Gets or sets an individual cookie value.
Values                      |Table                             |Gets a collection of key/value pairs that are contained within a single cookie object.


You can set the expires date like :

```lua
context.Response.Cookies["ID"].Expires = System.Date.Now:AddDays(30)
```

Also sub-items can be added like :

```lua
context.Response.Cookies["ID"].Values["Age"] = 33
context.Response.Cookies["ID"].Values["Gender"] = "male"
```


## System.Web.HttpSession

The http session is used to track the unique client, it may use several ways to identify the client, for now, the system and [NgxLua][] only provide the implementation based on the cookies.

When a http request send to the server and any logic access the **Session** from the http context for the first time, a session object will be created, so it's a lazy loading.

Before we dicuss how to generate the session object, we have to see the details of the session object:

Final Property              |Type                              |Description
:---------------------------|:---------------------------------|:-------------------------
Context                     |HttpContext                       |The http context of the session
Items                       |String                            |An indexer property used to sets or gets values, the values should be serializable
SessionID                   |String                            |Gets the unique identifier for the session
Timeout                     |String                            |Gets or sets the date time, allowed the next request access the session
TimeoutChanged              |String                            |Whether the time out is changed
Canceled                    |String                            |Whether the current session is canceled
IsNewSession                |String                            |Whether the session was created with the current request or its timeout is changed
ItemsChanged                |String                            |Whether the session items changed

We can save or get values from the **Items** :

```lua
__Route__("/test", HttpMethod.GET)
__Json__() function writecookie(context)
	context.Session.Items.user = "TestUser1234"
	return {}
end
```

In the business code, we only need use the **Items** property. The other properties are used by the frameworks.

The main problem of the **Session** is how we save the identify in the client, and how we save the session in the server.


### System.Web.ISessionIDManager

For each session object, the unique value is the **SessionID**, so the question is how we generate the **SessionID** and how we save it in the client, the **ISessionIDManager** is the interface to manage the session IDs.

Any implementation must provide those methods:

Abstract Method             |Arguments                                  |Description
:---------------------------|:------------------------------------------|:-------------------------
GetSessionID                |context: HttpContext                       |Gets the session identifier from the context of the current HTTP request.
CreateSessionID             |context: HttpContext                       |Creates a unique session identifier.
RemoveSessionID             |context: HttpContext                       |Deletes the session identifier in the current HTTP response.
SaveSessionID               |context: HttpContext, session: HttpSession |Saves a newly created session identifier to the HTTP response.
ValidateSessionID           |id: String                                 |Validate the session id

You can find an implementation **System.Web.GuidSessionIDManager** in the **PLoop**, it use the cookie to save the session id, and would use **System.Guid** to generate the session id.

Here is an example to create it:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	-- Session ID Manager
	GuidSessionIDManager { CookieName = "TestWebSessionID", TimeoutMinutes = 1 * 24 * 3600, Application = _ENV }
end)
```

The id manager is a global context handler be used by all http context of the same application, so in the application, we only need to create it for one time.

For the example, we create an id manager who use the *TestWebSessionID* in the cookie, and the time out should be 1 day.


### System.Web.ISessionStorageProvider

The session should be saved in the server or other data server like redis, so the next time the same user send a http request, we can use the saved values in the session, so you always need only save serializable values in the session.

The **ISessionStorageProvider** is the interface to manage the session storage, the implementation of it must provide those methods:

Abstract Method             |Arguments                                  |Description
:---------------------------|:------------------------------------------|:-------------------------
Contains                    |id: String                                 |Whether the session ID existed in the storage.
GetItems                    |id: String                                 |Get session item
RemoveItems                 |id: String                                 |Remove session item
SetItems                    |id: String, item: Table, timeout: Date/nil |Update the item with current session data
ResetItems                  |id: String, timeout: Date                  |Update the item's timeout
TrySetItems                 |id: String, item: Table, timeout: Date/nil |Try sets the item with an un-existed key, return true if success

In the **PLoop**, a **TableSessionStorageProvider** is provided, but since it's not thread-safe, it's only used for test. In the [NgxLua][], **ShareSessionStorageProvider** and **RedisSessionStorageProvider** is provided, the first would use the share table provided by the [Openresty][], it's simple and useful for small scale web service or development, the second use the redis server.

Here is the example to use them:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	-- Storage
	-- NgxLua.ShareSessionStorageProvider("havc_session_storage", application)
	NgxLua.RedisSessionStorageProvider({ host = "127.0.0.1", port = 6379 }, application)
end)
```

The *havc_session_storage* is a share table defined in the *nginx.conf*, like the id manager, the storage provider is also a global context handler, we only need to create one for the application.


## System.Web.Route

The **Route** system is a little complex, but luckly, we only need use the `__Route__` attribute to bind the url to their handlers, the previous examples has shown the static url handlers, ther have no patterns, the system will only use a hash table to save them, and can get the handler by one access.

But we can't make all features just by the static url handlers, and the disadvantage of it is we need to restart the web service when we modify them.

We still need dynamic routes and dynamic handlers.

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	__Route__ ".lsp"
	function LuaServerPage(context)
		return context.Request.Url
	end
end)
```

Sine there is no attribute like `__View__`, `__Json__` that describe the response of the request, the return value will be used a the absolute path to the resource file.

So for the url like `/home/index.lsp`, the file index.lsp in the /home dir will be used.

The `.lsp` let the system know which resouce loader should be used, and then the file will be converted to a class(or get the class if already created), an object will be generated from the class to handle the request.

Since those resource files can be reloaded by the resource system, we can modify them and see the changes without restart the web service, although the reload behavior must be turn off when publish it. We'll see how to change it in the configuration part.


## Page Rendering

### Lua Server Page (.lsp)

Normally we should use the MVC framework instead of the lua server page, but it's a good start for the page rendering.

To create a simple html page like:

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>PLoop.System.Web Test Page</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
	</head>
	<body>
		<p>
			This is the first PLoop.System.Web test page.
		</p>
	</body>
</html>
```

Just copy the content to a .lsp file (like index.lsp). The lsp file contains the html and lua code and will be converted to a page class, then it would be used to handle the http request and generate the response.

The **PLoop** only provided one page render engine **System.Web.PageRenderEngine**, so all template files will follow the same rules. We'll see how to create another page render engine at the last.


### Master Page (.master)

When you need to apply the same layout for several lsp files, it's best to create a master page that incldue the most common parts.

A master page file is ended with ".master". So if we create a "mymaster.master" with the content :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>@{title My web site}</title>
		@{jspart <!-- javascript placeholder -->}
	</head>
	<body>
		@{body}
	</body>
</html>
```

The render engine use *@* as the directive, it means an instruction here to be executed.

The `@{title My web site}` is used to declare a **web part** that would be replaced by child page classes, *title* is it's name, the rest are default text, if the web part is not defined in the child page, the default text would be used.

Then the *index.lsp* :

```HTML
@{ master = "mymaster.master" }

@title{
	PLoop.System.Web Test Page
}

@body{
	<p>
		This is the first PLoop.System.Web test page.
	</p>
}
```

There is a special rule for all template files(no matter if it use a custom page render engine), if the first line of the file contains a lua table, it would be parsed as the page's configuration.

In here the *master* means the page class's super class, the *index.lsp* can also be used as another lsp file's master page, so the web part can be declared in both master page and the lua server page. Since the *index.lsp* inherited the *mymaster.master*, the *index.lsp* only need to define the web parts.

To implement a web part, the `@name{` and `}` must be on each line's head, and the content must have an indent(tab or space) for each line, so the render engine will know the begin and the end of it.

Beware, you must keep using the same indent style for one files (only use tab or only use space, and keep the start and end part with same indents).

If the page don't provide a web part, it would be leave empty or use the web part's default value. So if it don't give the *title* part, the output content should be `<title>My web site</title>`.

The output result of *index.lsp* would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>PLoop.System.Web Test Page</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<p>
			This is the first PLoop.System.Web test page.
		</p>
	</body>
</html>
```

### Super web part

We can override the master page's web part, but we also may need to show the contents come from the master page, unlike the code we can use `super:test()`, we could use `@{super:body}` to generate the *body* web part designed in its master pages(or other super pages):

```html
@{ master = "index.lsp" }


@body{
	@{super:body}
	<p>
		This is the a PLoop.System.Web test page.
	</p>
}
```


### Mix HTML with lua

To embed Lua into html, there are four ways within the default page render engine :

#### Block

Used to define pure lua functions, also can be used to define the page class's method and other features :

```lua
@{
	local function rollDice(num, max, add)
		local sum = add

		for i = 1, num do
			sum = sum + math.random(max)
		end

		return sum
	end
}
```

Define a block of lua code is like defining a web part without name, it would be pure lua code in the block, if the function is not defined as local, it would be a class-method of the page class. The function and any variables defined in it can be used by anywhere that below the block.


#### Inline

Used to print an expression value, if the expression is not clear, the expression should be enclosed in parentheses, if use `@\`, the value would be encoded (or in the page configuration, use `encode=true` to force encoding all inline expressions) :

```html
@body{
	<p>Roll a dice(5d6+3) : @rollDice(5, 6, 3) </p>
	<p>encode test : @\"<test/>" </p>
}
```
The output should be like

```html
	<p>Roll a dice(5d6+3) : 22</p>
	<p>encode test : &lt;test/&gt; </p>
```

Things like `@a`, `@b`, `@(a+b)`, `@rollDice(5, 6, 3)` are inline codes, an inline code should be an expression that return a value, the value would be converted to a string to be displayed.

For the `a + b` expression, `@a + b` would confuse the system, it will treate the `@a` is a inline code, and the `+ b` is normal text, you should use parentheses around it.

The system can realize complex expression like `@King.Parent:Greet( Person{ Name = "Ann" } )`, also can realize string word like `@'test'`, `@"test"` or `@[=[test]=]`.


#### Full-line

Normally used to generate the control structure to control how the content would be generated, use '@>' to mark the full line is lua code, if the first word of the line is a keyword like 'local', 'if', 'for', you can only use '@' at the start of the line, and `@--` would be used for full line comments :

```html
@body{
	@ local a, b = math.random(100), math.random(100)
	<p>@a + @b = @(a+b)</p>

	<p>Roll a dice(5d6+3) : @rollDice(5, 6, 3) </p>

	<p>
	@ local hour = Date.Now.Hour
	@ if hour < 11 then
		Good morning
	@ elseif hour > 20 then
		Good night
	@ end
	</p>
}
```

The *body* web part will be converted to one function, so you can declare any local variables and use any structures like `if-then-end`, `while-do-end`, `for-end`.  The control structures must be full-line.

The result should be

```html
	<p>81 + 87 = 168</p>

	<p>Roll a dice(5d6+3) : 24 </p>

	<p>
		Good night
	</p>
```


#### Mixed Method

If we take the web part implement as function with zero-argument. We also can define function with arguments, it's called mixed method :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

Here we defined a local method *appendVerSfx*, and then defined a mixed method to use it. The mixed method is used to generate javascript elements with name and version arguments.

Here is how to use it :

```html
@{ master = "mymaster.master" }

@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}
```

It's just like how to declare web parts, but there are a big different between them, when using mixed methods, the mixed method's definition are already know, when declare the web parts, their definition are unknow.

The result would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript" src="/js/index.js?v=3"></script>
	</head>
	<body>

	</body>
</html>
```

The lua blocks can also be used in a web part or mixed method like :

```html
@body{
	<p>
		@ {
			local hour, msg = tonumber(os.date():match("(%d+):"))
			if hour < 10 then
				msg = "Good morning"
			elseif hour > 20 then
				msg = "Good night"
			else
				msg = "Have a nice day"
			end
		}
		@msg
	</p>
}
```

Beware of the indents, the render engine don't do a semantic analysis for the code, so it won't know where the block stoped if the indents don't match. The output should be :

```html
<p>
	Good night
</p>
```


### Helper Page (.helper)

The mixed methods are generaly used as help methods, so it's better to store them in one file, those files are helper pages. Unlike other type pages, the helper page would be converted to an interface, so it can be used by any other page classes.

We can set the helper to master page directly, so all the lua server pages that inherit it can use those mixed methods.

With the *globalhelper.helper* :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}
```

Re-write the *mymaster.master* :

```html
@{ helper = "globalhelper.helper" }

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>@{title My web site}</title>
		@{jspart <!-- javascript placeholder -->}
	</head>
	<body>
		@{body}
	</body>
</html>
```

So the *index.lsp* :

```html
@{ master = "mymaster.master" }

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}
```


### Embed Page (.embed)

By using `@[path default]`, we can embed other page files into the page. Normally, require the file with ".embed" suffix, but master and serer page can also be used(not recommend).

So with the given *notice.embed* file :

```html
<h2>
	Here is a description for test page<br/>
	To show how to use embed web pages.
</h2>
```

Re-write the *index.lsp* :

```html
@{ master = "mymaster.master" }

@body{
	@[notice.embed <!-- Notice placeholder -->]
}
```

And the result would be

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<h2>
			Here is a description for test page<br/>
			To show how to use embed web pages.
		</h2>
	</body>
</html>
```

If delete the *notice.embed* file, the output would be :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<!-- javascript placeholder -->
	</head>
	<body>
		<!-- Notice placeholder -->
	</body>
</html>
```

It's also possible to use the inline code in the *path* and *default*, since it would required some parameters, it's better to define it in the helper file - *globalhelper.helper* :

```html
@{
	local function appendVerSfx(path, version, suffix)
		return path .. suffix .. (version and "?v=" .. tostring(version) or "")
	end
}

@javascript(name, version) {
	<script type="text/javascript" src="/js/@appendVerSfx(name, version, '.js')"></script>
}

@javascriptInc(name, version, id) {
	<script type="text/javascript">
		@[/js/@appendVerSfx(name, nil, '.js') // /js/@appendVerSfx(name, version, '.js')]
	</script>
}
```

Now, for the *index.lsp* :

```html
@{ master = "mymaster.master" }

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascriptInc("index", 3) }
}
```

If the js file not existed :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript">
			// /js/index.js?v=3
		</script>
	</head>
	<body>

	</body>
</html>
```

If it existed :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>My web site</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript">
			$(function(){
				var _Ver = 1.0;
			})
		</script>
	</head>
	<body>

	</body>
</html>
```

The css files can also be emebed into page files. It's better to keep using file links in working versions, and change to emebed mode when published, you can do it by only changing some codes in the helper files.

The js and css files are all static files, if they existed as links, those files would be handled by a web server. If they are marked as embed, they'll be loaded into classes, this is done by **System.Web.JavaScriptLoader** and **System.Web.CssLoader**, the two loaders don't use the **System.Web.PageRenderEngine**, so the js and css file's content are written to the reponse directly.


### Inner Request Page

Besides the embed pages, we also could embed the response of other request, like response from a static route handler, or a controller of the MVC framework. Since the request is raised on the server, it's called the inner request, to diff it from the embed pages, we use another style :

```html
@[~path (param, httpmethod)]
```

Like the embed page, the in-line code can be used in the path, the params will be used as the querystring or form based on the http method(default is GET)

Here is an example

```html
@[~/tag/list ({id=1})]
```


### Lua Code file (.lua)

For one http request, the Lua Server Page's execution will be divided into two steps :

* Call the page object's *OnLoad* method with the http context object, and generate the response header, so if you need validate request's parameters or redirect to other url, you should do it here.

* Call the page object's *Render* method to generate the response body. The *Render* method is generate by the render engine, so you shouldn't care about it.

To define the *OnLoad* method, we can do it within the *index.lsp* by using block code :

```html
@{ master = "mymaster.master" }

@{
	function OnLoad(self, context)
		-- Generate a cookie
		context.Response.Cookies["TestCookie"].Value = "Test"
		context.Response.Cookies["TestCookie"].Expires = System.Date.Now:AddMinutes(10)
	end
}
```

It'd be more clear to split the code and the html template, we can define the code part in a lua file, and then bind it to the *index.lsp*.

Here we define the *index.lua* :

```lua
class "Index" {}

function Index:OnLoad()
	self.PageTitle = "Test Page"

	self.Data = {
		{ Name = "Ann", Age = 12 },
		{ Name = "King", Age = 32 },
		{ Name = "July", Age = 22 },
		{ Name = "Sam", Age = 30 },
	}
end
```

We define the class *Index* in the first line, the class's name should be the same with the file's name(case ignored), we don't give it the super class and other settings because that would be easy to set in the *.lsp* file.

Then give it an *OnLoad* method, in the method, we just init it with *PageTitle* and *Data* values.

Now, we can use *PageTitle* and *Data* in the *index.lsp* :

```html
@{ master="mymaster.master", code="index.lua" }

@title{
	@self.PageTitle
}

@jspart{
	@{ javascript("jquery-2.1.4.min") }
	@{ javascript("index", 3) }
}

@body{
	<table border="1">
		<thead>
			<tr>
				<th>Person Name</th>
				<th>Person Age</th>
			</tr>
		</thead>
		<tbody>
		@> for _, data in ipairs(self.Data) do
			<tr>
				<td style="background-color:cyan">@data.Name</td>
				<td>@data.Age</td>
			</tr>
		@> end
		</tbody>
	</table>
}
```

The *self* is the object created by the page class to handle the http request, you can use it in any web parts, html helpers, inline and full-line codes, it can't be used in local functions unless you pass the self to them.

The output is :

```html
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Test Page</title>
		<script type="text/javascript" src="/js/jquery-2.1.4.min.js"></script>
		<script type="text/javascript" src="/js/index.js?v=3"></script>
	</head>
	<body>
		<table border="1">
			<thead>
				<tr>
					<th>Person Name</th>
					<th>Person Age</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="background-color:cyan">Ann</td>
					<td>12</td>
				</tr>
				<tr>
					<td style="background-color:cyan">King</td>
					<td>32</td>
				</tr>
				<tr>
					<td style="background-color:cyan">July</td>
					<td>22</td>
				</tr>
				<tr>
					<td style="background-color:cyan">Sam</td>
					<td>30</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
```

Normally we don't need to use the Lua server page and its lua files, the MVC framework is a better choice.


## System.Web.MVC

We use the ".view" files as the view, it also use the **PageRenderEngine** so it follow the same rules of the ".lsp" files. Unlike the lua server page, the business code is done in the controllers, not the page class.

We also use the dynamic route to load the controllers, so the first thing is register a route map the url to the controllers:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

main("/user")
```

This is a special route settings, besides the Lua patterns, the route pattern also support a special usage:

* the `{xxxx}` will be used as a capture
* the `{xxxx?}` means the section can match empty string(ignored), the "/" after it will also be ignored
* the `{xxxx|pattern}` the pattern after the "|" will be used to match the string, they are normal Lua patterns
* All captures will be send to the function

The first return value of the function will be used to retrieve the request handler class, and the second value will be used as the init-table for the class to generate the object to handle the request.

Here is some examples:

Url                 |Path                              |Init-table
:-------------------|:---------------------------------|:--------------------
/                   |/controller/homecontroller.lua    |{ Action = "index" }
/user               |/controller/usercontroller.lua    |{ Action = "index" }
/user/profile       |/controller/usercontroller.lua    |{ Action = "profile", ID = 1 }
/topic/list/1       |/controller/topiccontroller.lua   |{ Action = "list", ID = 1 }


### System.Web.Controller

Save the previous code into a file as *test.lua*, and save the below code as *usercontroller.lua* in the same directory of the test file:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	function index(self, context)
		self:Text("This is the home page of user")
	end
end)
```

We don't need to set a module for the file, since it's loaded by the Application "TestWebApp", the file will be processed in the application.

Now you can process the test file, the result should be

```lua
-- This is the home page of user
main("/user")
```

The `__Action__` attribute is used to bind the *Action* to the method, it has two constructors:

Constructor Arguments                                 |Description
:-----------------------------------------------------|:-----------------------------
action: String, method: HttpMethod/HttpMethod.ALL     |Bind the method to the action with the http method
method: HttpMethod/HttpMethod.ALL                     |Use the method name as action, and bind the method to the action with the http method

The **Controller** class has provided several methods to generate the outputs:

Method                  |Arguments                             |Description
:-----------------------|:-------------------------------------|:--------------------------------
Text                    |text: String                          |Send the text as response
Text                    |iter: Functon, ...: Any * 0           |Send the text generated from the iterator as response
View                    |path: String, ...: Any * 0            |Render a page from file with the data as response
Json                    |data: Any, type: AnyType/nil          |Format the data as JSON format and send it as response
Redirect                |path: String, raw: Boolean/false      |Redirect to another url
NotFound                |                                      |Return 404

First let save the below template as *user.view* in the same directory:

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Hi, I'm @self.name of @self.age years old</p>
	</body>
</html>
```

Then change the *usercontroller.lua* to:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	function index(self, context)
		self:Text("This is the home page of user")
	end

	__Action__()
	function data(self)
		self:Json({ name = "Ann", age = 21 })
	end

	__Action__()
	function view(self)
		self:View("user.view", { name = "Ann", age = 21 })
	end
end)
```

We'll have the result like:

```lua
-- This is the home page of user
main("/user")

-- {"name":"Ann","age":21}
main("/user/data")

-- <html>
--     <head>
--         <title>Ann</title>
--     </head>
--     <body>
--         <p>Hi, I'm Ann of 21 years old</p>
--     </body>
-- </html>
main("/user/view")
```

You can also use the `__View__`, `__Text__`, `__Json__` attribute on them:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__()
	__Text__() function index(self, context)
		return "This is the home page of user"
	end

	__Action__()
	__Json__() function data(self)
		return { name = "Ann", age = 21 }
	end

	__Action__()
	__View__"user.view" function view(self)
		return { name = "Ann", age = 21 }
	end
end)
```

With the style, it's very simple to toggle the response format.


## Form Validation

Each http request will bring in the query string or form datas, we need to validate them and convert them to code type values, there is no need to let the developers keep doing this for each request handlers or controller's actions.

The `System.Web.__Form__` attribute is used to bind the form validation informations to the handlers or actions, and will finish the validation and conversion, the result will be passed to the handlers or actions.

Let's start with an example, continue use the action test, so you only need to replace the code in the *usercontroller.lua*.

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ {
		name  = { type = String, require = true },
		age   = { type = Number, require = true },
	}
	__Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end
end)
```

The result would be
```lua
-- {"Form":{"name":"ann","age":"2n1"},"Error":{"age":"the %s must be number"}}
main("/user/query", { name = "ann", age = "2n1" })

-- {"Form":{"name":"ann"},"Error":{"age":"the %s can't be nil"}}
main("/user/query", { name = "ann" })
```

For the error messages, you can use `Struct.GetErrorMessage(msg, "age")` to get the error message to be shown on the page.

If you noticed, the `__Form__` will receive a table of the struct type definition, and in it, the table will also be used to create a member struct type used to validate the querystring or the form.

It also support complex query structure like :

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ {
		person = struct {
			struct {
				name = String,
				age  = Number,
			}
		}
	}
	__Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end
end)
```

That means the person is a array struct, whose elements is a table with *name* and *age* values. So the test result will be:

```lua
-- {"Form":{"person":[{"name":"Ann","age":21},{"name":"Ben","age":23}]}}
main("/user/query", {
	["person[1].name"] = "Ann",
	["person[1].age"]  = "21",
	["person[2].name"] = "Ben",
	["person[2].age"]  = 23,
})

-- {"Form":{"person":[{"name":"Ann","age":"n"},{"name":1,"age":23}]},"Error":{"person":[{"age":"the %s must be number"},{"name":"the %s must be string, got number"}]}}
main("/user/query", {
	["person[1].name"] = "Ann",
	["person[1].age"]  = "n",
	["person[2].name"] = 1,
	["person[2].age"]  = 23,
})
```

If there is no error, the *err* argument will be nil, so the developers can check it to decide which response should be sent.

You can define custom struct to provide special error message, but keep in mind, if a value must be number, your custom struct must use the **Number** or any struct type based on the **Number** as its base type, so the validation system know that the value should be converted to a number.


## User Authentication

Before process the handlers or actions, we may need to check whether the user is login, or the user has the authority to access the url.

The **PLoop** has provided a `System.Web.__Login__` attribute to simple the task. It'd provide the login validation and the priority checking. You always can create your own features to replace it.


### Login validation

The `__Login__` will check the session if it has a special key saved, if so, the login validation is passed and the process will be turn to the real handlers or actions.

If the key don't existed, the system will redirect the client to the login page with the current url, so when the user login, he will be redirected to the previous url.

There are three settings must be made, the *Key* in the session, the *LoginPage* that where should be redirected to, and the *PathKey* that send to the *LoginPage* with the current url.

The Application has a property `_Config` can be used for configurations(see the 014.configuration for more informations), those can be set like :

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	-- Configuration
	_Config            = {
		Validator      = {
			Key        = "userid",
			LoginPage  = "/user/login",
			PathKey    = "path",
		}
	}

	-- Route
	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)
```

Here is an usage example:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ { person = struct { struct { name = String, age  = Number, } } }
	__Login__() __Action__() __Json__() function query(self, context, form, err)
		return { Form = form, Error = err }
	end

	__Action__("login", HttpMethod.GET) __View__"login.view"
	function loginview() end

	__Form__ {
		userid  = { type = String, require = true },
		password= { type = Password, require = true },
		path    = String,
	}
	__Action__("login", HttpMethod.POST) __Redirect__()
	function login(self, context, form, err)
		if err then return "/user/login" end
		context.Session.Items["userid"] = form.userid
		return form.path or "/"
	end
end)
```

If the user is not login, access the `/user/query` will be redirected to `/user/login?path=%2Fuser%2Fquery`

You should set the *Key* to session and redirect to the *Path* in the login page handlers.


### Authority Checking

The priority checking is a little complex, since the system won't know how your authority system is designed.

First you should give parameters to the `__Login__` attribute as the authority requirement for the url.

Then you must add a **AuthorityChecker** function in the `_Config.Validator`, the function will recieve the context and the authority requirement and return two value.

If the first value is true, the user passed the checking, the handler will process the operations, if false, the second value will be used as the redirect path.

Here is an example:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", Application  }

	-- Configuration
	_Config                  = {
		Validator            = {
			Key              = "userid",
			LoginPage        = "/user/login",
			PathKey          = "path",
			AuthorityChecker = function (context, requirement, path)
				if context.Session.Items.level >= requirement then
					return true
				else
					return path or "/user/forbidden"
				end
			end,
		}
	}

	-- Route
	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
```

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Form__ { person = struct { struct { name = String, age  = Number, } } }
	__Login__(4, "/user") __Action__() __Json__()
	function query(self, context, form, err)
		return { Form = form, Error = err }
	end

	__Action__("login", HttpMethod.GET) __View__"login.view"
	function loginview() end

	__Form__ {
		userid  = { type = String, require = true },
		password= { type = Password, require = true },
		path    = String,
	}
	__Action__("login", HttpMethod.POST) __Redirect__()
	function login(self, context, form, err)
		if err then return "/user/login" end
		context.Session.Items["userid"] = form.userid
		context.Session.Items["level"] = 1
		return form.path or "/"
	end

	__Action__()
	__Text__() function forbidden()
		return "You have no right"
	end
end)
```


## Context Handler

The process of the request is defined in the **System.Web.IHttpContextHandler**, all context handlers should extend the interface, the **Controller** extend it, the static route functions also will be wrapped as an object that extend the interface.

Here is the features provided by the interface

```lua
--- the http context process phase
__Flags__() __Sealed__()
enum "System.Web.IHttpContextHandler.ProcessPhase" {
	"Init",
	"Head",
	"Body",
	"Final"
}

--- the http context handler's priority
__Sealed__() __Default__(0)
enum "System.Web.IHttpContextHandler.HandlerPriority" {
	Highest                 =  2,
	Higher                  =  1,
	Normal                  =  0,
	Lower                   = -1,
	Lowest                  = -2,
}
```

Abstract Property       |Type                   |Default             |Description
:-----------------------|:----------------------|:-------------------|:--------------------
IsRequestHandler        |Boolean                |false               |Gets or sets whether the handler would check the request is already handled, only for init process phase, if the request is handled and the IsRequestHandler is true, the handler won't be use.
ProcessPhase            |ProcessPhase           |Head + Body         |Gets or sets the handler's process phase
Priority                |HandlerPriority        |Normal              |Gets or sets the handler's priority
AsGlobalHandler         |Boolean                |false               |Gets or sets whether the context handler is used as global handler.
Application             |Application            |                    |Gets or sets the target web application of the global handler

Abstract Method         |Arguments                                   |Description
:-----------------------|:-------------------------------------------|:--------------------
Process                 |context: HttpContext, phase: ProcessPhase   |Process the http request


Method                  |Arguments                                   |Description
:-----------------------|:-------------------------------------------|:--------------------
RegisterToContext       |context: HttpContext/nil                    |Register self to the context or the current context as temporary handlers

Take the **Route** as example, all routes are managed by the **RouteManager**, each web application has only one route manager, the route manager is a global handler register for the **ProcessPhase.Init** phase, it's a request handler, so it won't be processed when the request is aleady handled.

The global handler means it'll be used for each request, so the route manger will check the request url to find a matched route, if it get one, it'll try get the temp context handler from it, like use the static route handlers directly, or generate a handler from the class generated from the target file. The handler will call its **RegisterToContext** method reigster itself to the context as a temp handler.

There are three context handlers.

* Temp handler                   - such like the static route handlers, the controller, the Lua sever pages are all temp handlers, they are registered to the http context, if the response is sent to the client, the http context will be disposed, so the temp handlers will be un-registered.

* Application Global Handler     - Those handlers are registered as global handler with application, so it'll only works for the http context of the same applications, the route managers are all application global handler.

* Server Global Handler          - Those handlers are registered as global handler without application, it works for all http context created in the server.


Take an example from [NgxLua][], this is used to save the cookies to the reponse, it's server global handler:

```lua
-- the handler to send cookies
IHttpContextHandler {
	ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
	Priority        = IHttpContextHandler.HandlerPriority.Lowest,
	AsGlobalHandler = true,
	Process = function(self, context, phase)
		if not context.IsInnerRequest then
			local cookies = context.Response.Cookies
			if next(cookies) then
				local cache = {}
				local cnt = 1
				for name, cookie in pairs(cookies) do
					cache[cnt] = tostring(cookie)
					cnt = cnt + 1
				end
				ngx.header['Set-Cookie'] = cache
			end
		end
	end,
}
```

The **IHttpContextHandler** has anonymous class, so can be used to generate the handlers directly.

We could use those global handlers to collect informations, like day-access times:

```lua
--- the handler to send cookies
IHttpContextHandler {
	ProcessPhase    = IHttpContextHandler.ProcessPhase.Head,
	Priority        = IHttpContextHandler.HandlerPriority.Lowest,
	AsGlobalHandler = true,
	Application     = application,
	Process = function(self, context, phase)
		if not context.IsInnerRequest then
			with(Redis())(function(redis)
				local count = redis:Execute("INCR", "HAVC:HAVC_DAY_ACCESS_COUNT")
				if count == 1 then
					local dt= Date.Now
					redis:SetExpireTime("HAVC:HAVC_DAY_ACCESS_COUNT", Date(dt.Year, dt.Month, dt.Day, 23, 59, 59))
				end
			end)
		end
	end,
}
```

This is an application global handlers used to save the access count.

The process of a request is splitted into four phases:

* Init    -- The init phase, used to prepare the context handlers, like register the temp handlers
	* Process the web global handlers
	* Process the application global handlers
* Head    -- The head phase, used to prepare the response head informations
	* Process the temp handlers
	* Process the application global handlers
	* Process the server global handlers
	* Send the headers to the client
* Body    -- The body phase, only processed when the request is not redirected
	* Process the temp handlers
	* Process the application global handlers
	* Process the web global handlers
	* Close the response
* Final   -- The final phase, used to release resources
	* Process the temp handlers
	* Process the application global handlers
	* Process the web global handlers

The handlers will only be processed for its register phases.

It's very interesting in the **Controller**, it's logic is processed over the three phases:

Let's take out the **Text** method as an example:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "This is a test message"

		self:Text(text)

		text = nil
	end
end)
```

We expand the **Text** method, it works like:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "This is a test message"
		print("[PHASE]", context.ProcessPhase)

        local res       = self.Context.Response
        if res.RequestRedirected or res.StatusCode ~= HTTP_STATUS.OK then return end

        res.ContentType = "text/plain"
        coroutine.yield() -- finish head sending

		print("[PHASE]", context.ProcessPhase)

        res.Write(Web.ParseString(text))

        coroutine.yield() -- finish body sending

		print("[PHASE]", context.ProcessPhase)
		text = nil
	end
end)
```

The result would be

```lua
-- [PHASE]    2
-- [PHASE]    4
-- [PHASE]    8
-- This is a test message
main("/user/query")
```

So after the `self:Text(text)`, it's very safe to release resouces or finish other tasks, it won't block the response.


## Error Handler

The web system would track the errors during the process, it also will track the errors of the template system which is more hard to debug.

But first, we need give it an error handler, it's also a configuration :

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", System.Web.IHttpContextHandler.ProcessPhase }

	_Config = {
		ErrorHandler            = function(err, stack, context)
			if context.ProcessPhase == ProcessPhase.Final then
				error(err, stack)
			else
				context:ProcessInnerRequest("/error", { error = err })
				context.Response:Close()
			end
		end,
	}

	__Route__ "/error"
	__View__ "error.view" [[
		<html>
			<head>
				<title>Error</title>
			</head>
			<body>
				<p>@self.error</p>
			</body>
		</html>
	]]
	function errorhandler(context)
		return { error = context.Request.QueryString.error }
	end

	__Route__ "/{controller?|%a*}/{action?|%a*}/{id?/%d*}"
	function MVC(context, controller, action, id)
		controller = controller ~= "" and controller or "home"
		action     = action     ~= "" and action     or "index"
		id         = tonumber(id)

		return ("/%scontroller.lua"):format(controller), { Action = action, ID = id }
	end
end)

-- The test code to simulate the http request
require "PLoop.System.IO"
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

main("/user/query")
```

We give an **ErrorHandler** to the `_Config`, it'll receive error, stack and context, we checked the `context.ProcessPhase`, since we can't send the response when it's already done, then we pass the error to the `/error` url.

Let's modify the *usercontroller.lua* and see the result:

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		local text = "hello" .. context.Request.QueryString.name
		self:Text(text)
	end
end)
```

```html
<html>
	<head>
		<title>Error</title>
	</head>
	<body>
		<p>xxxxx/usercontroller.lua:5: attempt to concatenate a nil value (field 'name')</p>
	</body>
</html>
```

Then let's modify the *user.view* and *usercontroller.lua*:

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Score: @(self.data > 60 and "Pass" or "Failed")</p>
	</body>
</html>
```

```lua
class "UserController" (function(_ENV)
	inherit "Controller"

	__Action__() function query(self, context)
		self:View("user.view", { name = "Ann", data = nil })
	end
end)
```

We'll get the result:

```html
<html>
	<head>
		<title>Ann</title>
	</head>
	<body>
		<p>Score: 		<html>
			<head>
				<title>Error</title>
			</head>
			<body>
				<p>xxxxxx/user.view:6:  attempt to compare number with nil</p>
			</body>
		</html>
```

Well, it's a little odd, since the response is sent as stream.


## Relative Path & Absolute Path

In the above examples, we use paths for master, helper, code, view and etc. Here are some details about the path :

* The root path can be get by HttpRequest.Root.

* Path started with "/" is an absolute path, combine the root path and the absolute path is the target file's path.

* Path not started with "/" is a relative path, combine current file's directory and the relative path is the target file's path.


## System.Web.Config

Like the `_Config` of the web application, the **System.Web.Config** provide the configurations for all applications in the server.

There are configurations defined in the **System.Web**:

Configuration Name   |Type                       |Description
:--------------------|:--------------------------|:--------------------------------
Debug                |Boolean                    |Whether reload the resources files when modified
LogLevel             |Logger.LogLevel            |Change the log level for the **PLoop** system
LogHandler           |Callable                   |Add a log handler
ErrorHandler         |Function                   |Add an error handler for all applications, normally should only be set by the web application

We must turn off the **Debug** when publish the web server, the modified time check is a greater cost. Only useful under development mode.


## Configuration For Templates

The template system also registered the configurations to the **System.Web.Config.View** and the web application's `_Config.View`.

Here is an example:

```lua
_Config = {
	View                    = {
		Default             = {
			master          = nil,
			helper          = nil,
			reload          = false,
			encode          = true,
			noindent        = true,
			nolinebreak     = true,
			linebreak       = "\n",
			engine          = nil, -- default System.Web.PageRenderEngine
			asinterface     = nil,
			export          = {
				error       = function(message, target)
					return Struct.GetErrorMessage(message, target)
				end,
			},
		},

		ViewPage             = {
			reload           = true,
		},
	},
}
```

The *View* contains all settings for each type template files:

Name             |Super                 |suffix                |Description
:----------------|:---------------------|:---------------------|:--------------------------------
Default          |                      |.*                    |For all template files
HtmlPage         |Default               |.*                    |For all html page files
StaticFile       |Default               |.*                    |For all static files
ViewPage         |HtmlPage              |.view                 |For view files
EmbedPage        |HtmlPage              |.embed                |For embed page files
PageHelper       |HtmlPage              |.helper               |For helper files
LuaServerPage    |HtmlPage              |.lsp                  |For the lua server page files
MasterPage       |HtmlPage              |.master               |For the master page files
CssFile          |StaticFile            |.css                  |For css files that used as resources
JavascriptFile   |StaticFile            |.js                   |For js files that used as resources

The settings will use its super's settings if it don't have one.

For those sub configurations:

Name           |Type                          |Description
:--------------|:-----------------------------|:-------------------------------
master         |String                        |The master page for all the type files
helper         |String                        |The helper page for all the type files
reload         |Boolean                       |Set all the type files whether reload when modified
encode         |Boolean                       |Set all the type files whether encode every expression
noindent       |Boolean                       |Set all the type files whether don't output indents
nolinebreak    |Boolean                       |Set all the type files whether don't output line break
linebreak      |String                        |Set the linkbreak to all the type files
engine         |- System.Web.IRenderEngine    |Set the render engine to the type files, normally don't set it
asinterface    |Boolean                       |Set all the type files whether the returned type should be an interface
export         |Table                         |A table whose items will be exported to the environment where the resource is generated, so it can use all variables defined in the table

The configuration in the resource file's head will override the settings provided here.

Normally only *noindent*, *nolinebreak* and *export* are need.

With the previous settings, a view like :

```html
<html>
	<head>
		<title>@self.name</title>
	</head>
	<body>
		<p>Score: @(math.random(100) > 60 and "Pass" or "Failed")</p>
	</body>
</html>
```

The result would be :

```html
<html><head><title>Ann</title></head><body><p>Score: Pass</p></body></html>
```

So you can reduce the reponse length just by two settings, you can apply those configuration on the application or on the **Web** for all applications.


## Custom Render Engine

The **PLoop** only provied two render engine : **System.Web.PageRenderEngine** used to support a template system like the Razor for Asp.Net, and the **System.Web.StaticFileLoader** used for static files like the css.

Now, we'll see how to create the custom render engines, this is based on the text analysis.

The render engine must extend the **System.Web.IRenderEngine** and provide several methods:

Abstract Method    |Arguments                                        |Description
:------------------|:------------------------------------------------|:-------------------------
Init               |loader: IOutputLoader, config: RenderConfig      |Init the engine with the page loader and the page config
ParseLines         |reader: TextReader                               |Parse the lines and yield all content with type

The **ParseLines** will be called within an iterator, the **IRenderEngine** has extend teh **Iterable** interface.

For the static files, the **ParseLines** is defined like :

```lua
function ParseLines(self, reader)
	-- Use yield not return to send back content and other informations
	coroutine.yield(RenderContentType.MixMethodStart, "Render")

	for line in reader:ReadLines() do
		line = line:gsub("%s+$", "")
		coroutine.yield(RenderContentType.RecordLine, line)

		coroutine.yield(RenderContentType.StaticText, line)

		coroutine.yield(RenderContentType.NewLine)
	end

	coroutine.yield(RCT_MixMethodEnd)
end
```

Here is the explains:

* We use the coroutine to yield all the op codes and data to make sure we can track the context of analysis.
* We yield the op code defined in the **RenderContentType**, so the system know how to use it to generate the page classes.
* The **RenderContentType.RecordLine** will be used to map the code line with the template line, so the system know where the bug comes from, it's very important.

Here are the op codes from the **RenderContentType**:

Name               |Parameters                                                       |Description
:------------------|:----------------------------------------------------------------|:------------------------------------
RecordLine         |line:String                                                      |record the line with the index for error location
StaticText         |text:String                                                      |the static text
NewLine            |                                                                 |write a new line
LuaCode            |line:String                                                      |the lua code line like `if xxx then`
Expression         |exp:String                                                       |the expression to be executed and write the result
EncodeExpression   |exp:String                                                       |the expression to be executed and the result must be encoded then sent out
MixMethodStart     |name:String                                                      |start the creation of a mix method
MixMethodEnd       |                                                                 |end the creation of the previous mix method
CallMixMethod      |name:String, params:String, default:String, issupercall:Boolean  |call a mix method with params, if not existed, use the default, if issupercall, then the super class's mix method will the name will be used, like the usage of the `@{super:body}`
RenderOther        |path:String, params:String, default:String                       |Render other files, like the embed pages
InnerRequest       |url:String, params:String                                        |Render with an inner request call

Now we have a **test.wf** template:

```html
html
	head
		title
			> my web site
	body
		div #mainDiv .center
			p #random style='width:100px'
				> random is {{ math.random(10000) }} pts
```

We'll create a custom engine and register a resource loader based on the engine for it:

```lua
PLOOP_PLATFORM_SETTINGS = { MULTI_OS_THREAD = true }

require "PLoop.System.Web"
require "PLoop.System.IO"

PLoop(function(_ENV)
	import "System.IO.Resource"
	import "System.Web"

	-- Define the render engine
	class "WaterFallEngine"(function (_ENV)
		extend "IRenderEngine"

		local yield 	= coroutine.yield

		local NOT_CHILD = 0
		local NODE_ELE 	= 1
		local TEXT_ELE 	= 2

		local function parseLine(self, reader, chkSpace, isFirstChild)
			line = self.CurrentLine or reader:ReadLine()

			self.CurrentLine = nil

			if not line then return NOT_CHILD end
			line = line:gsub("%s+$", "")

			local space, tag, ct = line:match("^(%s*)(%S+)%s*(.*)$")

			space = space or ""

			if tag == ">" then
				-- It's a text element
				-- for "random is {{ math.random(10000) }} pts"

				local startp = 1
				local expSt, expEd = ct:find("{{.-}}", startp)

				while expSt do
					-- "random is " is static text
					yield(RenderContentType.StaticText, ct:sub(startp, expSt - 1))

					-- math.random(10000) is an expression
					yield(RenderContentType.Expression, ct:sub(expSt + 2, expEd - 2))

					startp = expEd + 1
					expSt, expEd = ct:find("{{.-}}", startp)
				end

				-- The remain " pts" is also static text
				yield(RenderContentType.StaticText, ct:sub(startp))

				return TEXT_ELE
			end

			-- Check if it's a child node
			if not chkSpace or #space > #chkSpace then
				-- This is a node
				-- for "		div #mainDiv .center"

				-- If the node is a child node, we need add a new line
				if chkSpace then
					if isFirstChild then
						yield(RenderContentType.NewLine)
					end

					-- "		" space is static text, don't forget it
					yield(RenderContentType.StaticText, space)
				end

				-- Get id, class and other settings
				local id, cls = "", ""
				local cache = { tag }

				-- Get and remove id from ct
				ct = ct:gsub("#(%w+)", function(w) id = w return "" end)
				if #id > 0 then
					table.insert(cache, ([[id="%s" name="%s"]]):format(id, id) )
				end

				-- Get and remove class from ct
				ct = ct:gsub("%.(%w+)", function(w) cls = cls .. w .. "," return "" end)
				if #cls > 0 then
					table.insert(cache, ([[class="%s"]]):format(cls:sub(1, -2)) )
				end

				-- Get the remain
				ct = ct:gsub("^%s*(.-)%s*$", "%1")
				if ct and #ct > 0 then
					table.insert(cache, ct)
				end

				-- "div #mainDiv .center" -> StaticText: <div id="mainDiv" name="mainDiv" class="center">
				yield(RenderContentType.StaticText, "<" .. table.concat(cache, " ") .. ">")

				-- check the next line
				local firstNode = true

				while true do
					local ret = parseLine(self, reader, space, firstNode)

					firstNode = false

					if ret == TEXT_ELE then
						-- Close the tag
						yield(RenderContentType.StaticText, "</" .. tag .. ">")

						-- Generate a new line
						yield(RenderContentType.NewLine)

						return NODE_ELE
					elseif ret == NODE_ELE then
						-- We have a child node, just keep parsing
					else
						-- we meet the end of the node
						if #space > 0 then
							yield(RenderContentType.StaticText, space)
						end

						-- Close the tag
						yield(RenderContentType.StaticText, "</" .. tag .. ">")

						-- Generate a new line
						yield(RenderContentType.NewLine)

						return NODE_ELE
					end
				end
			else
				-- This is not a child node, so return to close the previous node
				self.CurrentLine = line

				return NOT_CHILD
			end
		end

		function ParseLines(self, reader)
			yield(RenderContentType.MixMethodStart, "Render")

			parseLine(self, reader)

			-- end
			yield(RenderContentType.MixMethodEnd)
		end
	end)

	__ResourceLoader__"wf"   -- Register for the .wf files
    __PageRender__("WaterFallPage", IOutputLoader, { engine = WaterFallEngine })  -- Bind the render engine
    class "System.Web.WaterFallPage" { IOutputLoader }
end)

app = Application "TestWebApp" (function(_ENV)
	export { "tonumber", System.Web.IHttpContextHandler.ProcessPhase }

	__Route__ "/index"
	__View__ "index.wf" [[
html
	head
		title
			> {{ self.name }} web site
	body
		div #mainDiv .center
			p #random style='width:100px'
				> random is {{ math.random(10000) }} pts
	]]
	function index(context)
		return { name = "Ann" }
	end
end)

-- The test code to simulate the http request
import "System.IO"
import("System.Web", true)

function main(url, query, method)
	local writer = IO.StringWriter()
	writer:Open()

	local ctx = HttpContext(app)

	method = method or HttpMethod.GET

	ctx.Request = HttpRequest(ctx)
	ctx.Request.HttpMethod = method
	ctx.Request.Root = IO.Path.GetCurrentPath()
	ctx.Request.Url = url

	if method == HttpMethod.GET then
		ctx.Request.QueryString = query
	else
		ctx.Request.Form = query
	end

	ctx.Response = HttpResponse(ctx)
	ctx.Response.Write = function(str) writer:Write(str) end
	ctx:Process()
	writer:Close()
	print(writer.Result)
end

-- <html>
--     <head>
--         <title>Ann web site</title>
--     </head>
--     <body>
--         <div id="mainDiv" name="mainDiv" class="center">
--             <p id="random" name="random" style='width:100px'>random is 4150 pts</p>
--         </div>
--     </body>
-- </html>
main("/index")
```


[PLoop.Browser]: https://github.com/kurapica/PLoop.Browser  "PLoop Lib Browser"
[nginx]: https://www.nginx.com/ "Nginx"
[Openresty]: https://github.com/openresty/lua-nginx-module/ "Openresty"
[NgxLua]: https://github.com/kurapica/NgxLua/ "An implementation for the Openresty"