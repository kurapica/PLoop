# Watch & Reactive

The reactive system is powerful but not easyly to be used, so the PLoop provide an easy way to hide the complex subscriptions.

```lua
require "PLoop" (function(_ENV)
    data = reactive {
        name = "Ann",
        info = {
            age = 23
        }
    }

    -- For 5.1 or with setfenv api, you can omit the `_ENV` here
    watch(function(_ENV) print(("[Name]%s, [Age]%d"):format(data.name, data.info.age)) end) -- [Name]Ann, [Age]23

    data.name = "Ben" -- [Name]Ben, [Age]23
    data.info.age = 40 -- [Name]Ben, [Age]40
end)
```

We create a reactive `data` with two fields `name` and `info.age`, the fields are all observable, then we create a watch function, the function will be processed immediality, and when the `name` or `info.age` changed, the watch function will be processed.

So, that means the watch function can detect the observable data it accessed and subscribe them for the changes.


## reactive

The `System.Reactive` lib provide a new keyword `reactive` used t ocreate observable data source easily. There is several way to use it.


### Reactive Object

We can use `reactive()` to create a reactive object, when we assign value to the reactive object and the field is first time used, an observable field will be added to the reactive object, the field will use a behavior subject to send the given value. We also can access the current value by the field name.

```lua
require "PLoop" (function(_ENV)
    data = reactive ()
    data.name = "Ann"

    watch(function(_ENV) print(data.name) end) -- Ann
    data.name = "Ben" -- Ben
end)
```

We can get the field's behavior subject for reactive operations.

```lua
require "PLoop" (function(_ENV)
    Logger.Default:AddHandler(print)

    data = reactive ()
    data.name = "Ann"

    data("name"):Map("x=>'Hello ' .. x"):Dump() -- [Info]Dump-->Hello Ann
    data.name = "Ben" -- [Info]Dump-->Hello Ben
end)
```

Also we can assign the field with an observable object, the behavior subject of the field will subscribe the value.

```lua
require "PLoop" (function(_ENV)
    subject = Subject()
    data = reactive()

    data.value = subject
    watch(function(_ENV) print(data.value) end) -- nil

    subject:OnNext(100) -- 100
    subject:OnNext(200) -- 200
end)
```


### Reactive With Raw Table

For the first example, we create the reactive object by table has no meta-table. Since the field `info` has a raw table, it will also be converted to a reactive object.


We also can add new observable field to those reactive objects, you can modify the first examples to see how it works.


### Reactive With Value

Besides the table, if we pass `number`, `string`, `boolean` value to `reactive`, we'll get a behavior subject.

```lua
require "PLoop" (function(_ENV)
    Logger.Default:AddHandler(print)

    data = reactive (100)
    data:Dump() -- [Info]Dump-->100

    data.Value = 200 -- [Info]Dump-->200

    print(data.Value) -- 200
end)
```

We can modify or get the value by its `Value` property.


### Reactive With Object

It's a little complex for using `reactive` on objects, there are several rules:

1. If the value is `Reactive` or `BehaviorSubject`, the value will be returned directly.

2. If the value is `IObservable`, a `BehaviorSubject` will be created to subscribe it, and the behavior subject will be returned.

3. If the value is a class has observable properties, the observabel fields will be generated based on those observable properties.

	```lua
	require "PLoop" (function(_ENV)
		-- Declare a class with two observable property
	    class "Person" (function(_ENV)
	        __Observable__()
	        property "Name" { type = String }

	        __Observable__()
	        property "Age" { type = Integer }
	    end)

	    ann = Person{ Name = "Ann", Age = 24 }

	    data = reactive (ann)
	    watch(function(_ENV) print(data.Name, data.Age) end) -- Ann 24

	    -- No matter change the original object or the reactive object
	    ann.Name = "Ben"    -- Ben 24
	    data.Age = 30       -- Ben 30
	    print(ann.Age)      -- 30
	end)
	```

	In this case, `data[field] = value` will be converted to `ann[field] = value`, so you can't create new observable field in the `data`.

4. Otherwise, error will be raised.



## watch

The `watch` is also a keyword provided by the `System.Reactive`. W

When a function is given, the `watch` will create a private environment for the function to call it. So the `watch` system will know which observable or reactive field is accessed by the function.

For Lua 5.2 and above, it's better to use `_ENV` as the given function's parameter.

As a complex example:

```lua
require "PLoop" (function(_ENV)
    switcher = reactive(false)
    data = reactive{
        on = "Go",
        off = "Stop"
    }

    -- Stop
    watch(function(_ENV)
        if switcher then
            print(data.on)
        else
            print(data.off)
        end
    end)

    -- Go
    switcher.Value = true

    -- Continue
    data.on = "Continue"
end)
```

When the function is first watched, the switcher will be subscribed and since it's value is `false`, the `data.off` will be subscribed.

When change the switcher to `true`, the function will access the `data.on`, so it's also subscribed now.

So when we change the `data.on` the function will also be processed.


### Watch With Special Observables

Since `watch` can only detect the global variable access, it'll fail when we use local variables.

```lua
require "PLoop" (function(_ENV)
    local switcher = reactive(false)
    local data = reactive{
        on = "Go",
        off = "Stop"
    }

    -- Since the switcher is a real object, it'll be treated as true
    -- Go
    watch(function(_ENV)
        if switcher then
            print(data.on)
        else
            print(data.off)
        end
    end)

    -- Nothing happens
    switcher.Value = true
    data.on = "Continue"
end)
```

To make it works, we can do it like

```lua
require "PLoop" (function(_ENV)
    local switcher = reactive(false)
    local data = reactive{
        on = "Go",
        off = "Stop"
    }

    -- Stop
    watch({
        rswitcher = switcher,
        rdata = data
    }, function(_ENV)
        if rswitcher then
            print(rdata.on)
        else
            print(rdata.off)
        end
    end)

    -- Go
    switcher.Value = true

    -- Continue
    data.on = "Continue"
end)
```

So if we provide those observable sources from other codes, we can use a table to organize them.


### Observable Watch

The `watch` will return a Watch object which inherit `BehaviorSubject`, so it's also observable.

```lua
require "PLoop" (function(_ENV)
    switcher = reactive(false)
    data = reactive{
        on = "Go",
        off = "Stop"
    }

    info = reactive{
        label = watch(function(_ENV)
            if switcher then
                return data.on
            else
                return data.off
            end
        end)
    }

    watch(function(_ENV) print("Info is " .. info.label) end) -- Info is Stop

    switcher.Value = true -- Info is Go
    data.on = "Continue"  -- Info is Continue
end)
```